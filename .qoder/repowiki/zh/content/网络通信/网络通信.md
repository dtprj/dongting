# 网络通信

<cite>
**本文档引用的文件**   
- [NioClient.java](file://client/src/main/java/com/github/dtprj/dongting/net/NioClient.java)
- [NioServer.java](file://client/src/main/java/com/github/dtprj/dongting/net/NioServer.java)
- [NioWorker.java](file://client/src/main/java/com/github/dtprj/dongting/net/NioWorker.java)
- [Packet.java](file://client/src/main/java/com/github/dtprj/dongting/net/Packet.java)
- [WritePacket.java](file://client/src/main/java/com/github/dtprj/dongting/net/WritePacket.java)
- [ReadPacket.java](file://client/src/main/java/com/github/dtprj/dongting/net/ReadPacket.java)
- [HandshakeProcessor.java](file://client/src/main/java/com/github/dtprj/dongting/net/HandshakeProcessor.java)
- [HandshakeBody.java](file://client/src/main/java/com/github/dtprj/dongting/net/HandshakeBody.java)
- [DtChannel.java](file://client/src/main/java/com/github/dtprj/dongting/net/DtChannel.java)
- [Peer.java](file://client/src/main/java/com/github/dtprj/dongting/net/Peer.java)
- [NioClientConfig.java](file://client/src/main/java/com/github/dtprj/dongting/net/NioClientConfig.java)
- [NioServerConfig.java](file://client/src/main/java/com/github/dtprj/dongting/net/NioServerConfig.java)
</cite>

## 目录
1. [简介](#简介)
2. [项目结构](#项目结构)
3. [核心组件](#核心组件)
4. [架构概述](#架构概述)
5. [详细组件分析](#详细组件分析)
6. [依赖分析](#依赖分析)
7. [性能考虑](#性能考虑)
8. [故障排除指南](#故障排除指南)
9. [结论](#结论)

## 简介
本文档详细描述了Dongting项目中基于Java NIO的网络通信层实现。重点介绍客户端(NioClient)和服务器(NioServer)的实现原理，包括连接建立、握手过程、数据包编解码和传输机制。文档还说明了网络层如何与上层的RAFT和KV逻辑进行交互，并详细描述了连接管理、超时处理和错误恢复策略，为需要理解或定制网络行为的用户提供参考。

## 项目结构
网络通信相关的核心代码位于client模块的`com.github.dtprj.dongting.net`包中，采用典型的NIO多线程架构设计。

```mermaid
graph TD
subgraph "网络层核心组件"
NioClient[NioClient]
NioServer[NioServer]
NioWorker[NioWorker]
NioNet[NioNet]
end
subgraph "数据包处理"
Packet[Packet]
WritePacket[WritePacket]
ReadPacket[ReadPacket]
HandshakeProcessor[HandshakeProcessor]
HandshakeBody[HandshakeBody]
end
subgraph "连接管理"
DtChannel[DtChannel]
Peer[Peer]
IoWorkerQueue[IoWorkerQueue]
end
NioClient --> NioNet
NioServer --> NioNet
NioWorker --> NioStatus
NioWorker --> IoWorkerQueue
NioClient --> Peer
NioClient --> NioWorker
NioServer --> NioWorker
NioServer --> DtChannel
NioWorker --> DtChannelImpl
WritePacket --> Packet
ReadPacket --> Packet
HandshakeProcessor --> ReqProcessor
HandshakeBody --> PbCallback
```

**图示来源**
- [NioClient.java](file://client/src/main/java/com/github/dtprj/dongting/net/NioClient.java#L37-L73)
- [NioServer.java](file://client/src/main/java/com/github/dtprj/dongting/net/NioServer.java#L30-L65)
- [NioWorker.java](file://client/src/main/java/com/github/dtprj/dongting/net/NioWorker.java#L80-L120)

## 核心组件
网络通信层的核心组件包括NioClient、NioServer、NioWorker和数据包处理相关类。NioClient和NioServer都继承自NioNet，共享基础网络功能。NioWorker负责实际的I/O操作，每个Worker对应一个线程。数据包通过WritePacket和ReadPacket进行编解码，支持多种数据类型和编码格式。

**组件来源**
- [NioClient.java](file://client/src/main/java/com/github/dtprj/dongting/net/NioClient.java#L37-L73)
- [NioServer.java](file://client/src/main/java/com/github/dtprj/dongting/net/NioServer.java#L30-L65)
- [Packet.java](file://client/src/main/java/com/github/dtprj/dongting/net/Packet.java#L15-L35)

## 架构概述
Dongting的网络通信层采用经典的Reactor模式，结合多线程工作模型，实现了高性能的网络I/O处理。

```mermaid
sequenceDiagram
participant Client as "NioClient"
participant Worker as "NioWorker"
participant Selector as "Selector"
participant Channel as "SocketChannel"
participant Server as "NioServer"
Client->>Worker : start()
Worker->>Selector : openSelector()
Worker->>Worker : start thread
loop Worker循环
Selector->>Selector : select()
Selector->>Worker : 返回就绪事件
Worker->>Worker : dispatchActions()
Worker->>Worker : 处理SelectionKey
alt 连接事件
Worker->>Channel : finishConnect()
Worker->>Worker : initNewChannel()
Worker->>Worker : sendHandshake()
else 读事件
Channel->>Worker : read()
Worker->>Worker : afterRead()
Worker->>Worker : 解码数据包
else 写事件
Worker->>Channel : write()
Worker->>Worker : afterBufferWriteFinish()
end
end
Server->>Worker : accept()
Worker->>Channel : accept()
Worker->>Worker : newChannelAccept()
Worker->>Worker : initNewChannel()
Worker->>Worker : 处理握手
```

**图示来源**
- [NioClient.java](file://client/src/main/java/com/github/dtprj/dongting/net/NioClient.java#L75-L95)
- [NioServer.java](file://client/src/main/java/com/github/dtprj/dongting/net/NioServer.java#L85-L115)
- [NioWorker.java](file://client/src/main/java/com/github/dtprj/dongting/net/NioWorker.java#L200-L300)

## 详细组件分析

### NioClient分析
NioClient是客户端网络组件，负责与服务器建立连接并发送请求。

```mermaid
classDiagram
class NioClient {
-NioClientConfig config
-NioWorker worker
-CopyOnWriteArrayList<Peer> peers
-Condition connectCond
-int connectCount
+NioClient(NioClientConfig config)
+doStart()
+onConnected(DtChannel dtc)
+onDisconnected(DtChannel dtc)
+waitStart(DtTime timeout)
+waitConnect(int targetConnectCount, DtTime timeout)
+sendRequest(WritePacket request, DecoderCallbackCreator<T> decoder, DtTime timeout)
+sendRequest(Peer peer, WritePacket request, DecoderCallbackCreator<T> decoder, DtTime timeout)
+sendOneWay(WritePacket request, DtTime timeout)
+addPeer(HostPort hostPort)
+removePeer(Peer peer)
+connect(Peer peer)
+disconnect(Peer peer)
}
class NioClientConfig {
+String name
+List<HostPort> hostPorts
+int connectTimeoutMillis
+int readBufferSize
+int maxPacketSize
+int maxBodySize
+int maxOutRequests
+long maxOutBytes
+int ioThreads
+int selectTimeout
+int cleanInterval
+boolean serverHint
+List<ChannelListener> channelListeners
+PoolFactory poolFactory
+PerfCallback perfCallback
+long nearTimeoutThreshold
}
NioClient --> NioNet : "继承"
NioClient --> NioClientConfig : "使用"
NioClient --> Peer : "包含"
NioClient --> NioWorker : "使用"
NioClient --> ChannelListener : "实现"
```

**图示来源**
- [NioClient.java](file://client/src/main/java/com/github/dtprj/dongting/net/NioClient.java#L37-L73)
- [NioClientConfig.java](file://client/src/main/java/com/github/dtprj/dongting/net/NioClientConfig.java#L15-L45)

### NioServer分析
NioServer是服务器端网络组件，负责监听端口并处理客户端连接。

```mermaid
classDiagram
class NioServer {
-NioServerConfig config
-ServerSocketChannel ssc
-Selector selector
-boolean stop
-Thread acceptThread
-NioWorker[] workers
-ConcurrentHashMap<UUID, DtChannel> clients
+NioServer(NioServerConfig config)
+doStart()
+run()
+select()
+doStop(DtTime timeout, boolean force)
+stopAcceptThread()
+forceStop(DtTime timeout)
+sendRequest(DtChannel dtc, WritePacket request, DecoderCallbackCreator<T> decoder, DtTime timeout, RpcCallback<T> callback)
+sendOneWay(DtChannel dtc, WritePacket request, DtTime timeout, RpcCallback<T> callback)
}
class NioServerConfig {
+String name
+int port
+int backlog
+int maxPacketSize
+int maxBodySize
+int maxInRequests
+long maxInBytes
+int ioThreads
+int selectTimeout
+int cleanInterval
+boolean serverHint
+List<ChannelListener> channelListeners
+PoolFactory poolFactory
+PerfCallback perfCallback
+long nearTimeoutThreshold
}
class PingProcessor {
+process(ReadPacket<RefBuffer> packet, ReqContext reqContext)
+createDecoderCallback(int command, DecodeContext c)
}
NioServer --> NioNet : "继承"
NioServer --> NioServerConfig : "使用"
NioServer --> NioWorker : "包含"
NioServer --> DtChannel : "管理"
NioServer --> PingProcessor : "注册处理器"
```

**图示来源**
- [NioServer.java](file://client/src/main/java/com/github/dtprj/dongting/net/NioServer.java#L30-L65)
- [NioServerConfig.java](file://client/src/main/java/com/github/dtprj/dongting/net/NioServerConfig.java#L15-L45)

### NioWorker分析
NioWorker是I/O工作线程，负责实际的网络I/O操作。

```mermaid
classDiagram
class NioWorker {
-String workerName
-WorkerThread thread
-NioStatus nioStatus
-NioConfig config
-NioNet owner
-Selector selector
-AtomicInteger wakeupCalledInOtherThreads
-boolean wakeupCalled
-CompletableFuture<Void> prepareStopFuture
-int channelIndex
-ArrayList<DtChannelImpl> channelsList
-IntObjMap<DtChannelImpl> channels
-IoWorkerQueue ioWorkerQueue
-Timestamp timestamp
-LinkedList<DtChannelImpl> incomingConnects
-LinkedList<ConnectInfo> outgoingConnects
-ByteBufferPool directPool
-ByteBufferPool heapPool
-WorkerStatus workerStatus
-ByteBuffer readBuffer
-long readBufferUseTime
-long cleanIntervalNanos
-long lastCleanNanos
-PerfCallback perfCallback
+run()
+run0(Selector selector, Timestamp ts)
+sel(Selector selector, Timestamp ts)
+processOneSelectionKey(SelectionKey key, int status, Timestamp roundTime)
+initNewChannel(SocketChannel sc, Peer peer)
+newChannelAccept(SocketChannel sc)
+connect(Peer peer, DtTime deadline)
+doConnect(CompletableFuture<Void> f, Peer peer, DtTime deadline, boolean byAutoRetry)
+whenConnected(SelectionKey key)
+sendHandshake(DtChannelImpl dtc, ConnectInfo ci)
+handshakeSuccess(DtChannelImpl dtc, ConnectInfo ci, ReadPacket<HandshakeBody> resp)
+doInIoThread(Runnable runnable, CompletableFuture<?> future)
+disconnect(Peer peer)
+close(DtChannelImpl dtc)
+closeChannel0(SocketChannel sc)
+cleanOutgoingTimeoutConnect(Timestamp roundStartTime)
+cleanIncomingConnects(Timestamp roundStartTime)
+tryReconnect(Timestamp ts)
+writeReqInBizThreads(PacketInfo data)
+doStart()
+doPrepareStop(DtTime timeout)
+doStop(DtTime timeout, boolean force)
}
class ConnectInfo {
+CompletableFuture<Void> future
+Peer peer
+SocketChannel channel
+DtTime deadline
+boolean byAutoRetry
}
class WorkerStatus {
+NioWorker worker
+IoWorkerQueue ioWorkerQueue
+ByteBufferPool directPool
+RefBufferFactory refBufferFactory
+Timestamp timestamp
+long nearTimeoutThreshold
+int packetsToWrite
+int pendingReqSize()
+void cleanAllPendingReq()
+void cleanPendingReqByTimeout()
+void cleanPendingReqByChannel(DtChannelImpl dtc)
+void finishHandshake(DtChannelImpl dtc)
}
NioWorker --> AbstractLifeCircle : "继承"
NioWorker --> IoWorkerQueue : "使用"
NioWorker --> WorkerStatus : "包含"
NioWorker --> ConnectInfo : "包含"
NioWorker --> DtChannelImpl : "管理"
NioWorker --> Peer : "使用"
```

**图示来源**
- [NioWorker.java](file://client/src/main/java/com/github/dtprj/dongting/net/NioWorker.java#L80-L120)
- [IoWorkerQueue.java](file://client/src/main/java/com/github/dtprj/dongting/net/IoWorkerQueue.java#L15-L30)

### 数据包处理分析
数据包处理是网络通信的核心，包括数据包的编解码和传输。

```mermaid
classDiagram
class Packet {
+static final int IDX_TYPE = 1
+static final int IDX_COMMAND = 2
+static final int IDX_SEQ = 3
+static final int IDX_RESP_CODE = 4
+static final int IDX_BIZ_CODE = 5
+static final int IDX_MSG = 6
+static final int IDX_TIMEOUT = 7
+static final int IDX_EXTRA = 8
+static final int IDX_BODY = 15
+int packetType
+int command
+int seq
+int respCode
+int bizCode
+String msg
+long timeout
+byte[] extra
}
class WritePacket {
+static final int STATUS_INIT = 0
+static final int STATUS_HEADER_ENCODE_FINISHED = 1
+static final int STATUS_ENCODE_FINISHED = 2
+int dumpSize
+int bodySize
+byte[] msgBytes
+volatile boolean acquirePermit
+int maxPacketSize
+boolean use
+boolean cleaned
+calcMaxPacketSize()
+actualBodySize()
+getMsgBytes()
+actualSize()
+encode(EncodeContext context, ByteBuffer buf)
+clean()
+doClean()
+prepareRetry()
+canRetry()
}
class ReadPacket {
+T body
+boolean responseHasWrite
+ReadPacket()
+getBody()
+setBody(T body)
}
class HandshakeBody {
+static final long MAGIC1 = 0xAE10_9045_1C22_DA13L
+static final long MAGIC2 = 0x1CD7_D1A3_0A61_935FL
+int majorVersion
+int minorVersion
+ProcessInfoBody processInfo
+ConfigBody config
+readFix64(int index, long value)
+readVarNumber(int index, long value)
+readBytes(int index, ByteBuffer buf, int fieldLen, int currentPos)
+actualSize()
+encode(ByteBuffer buf)
}
class ConfigBody {
+int maxPacketSize
+int maxBodySize
+int maxInPending
+long maxInPendingBytes
+int maxOutPending
+long maxOutPendingBytes
+readVarNumber(int index, long value)
+getResult()
+actualSize()
+encode(ByteBuffer buf)
}
class ProcessInfoBody {
+long uuid1
+long uuid2
+readFix64(int index, long value)
+getResult()
+encode(ByteBuffer buf)
+actualSize()
}
WritePacket --> Packet : "继承"
ReadPacket --> Packet : "继承"
HandshakeBody --> PbCallback : "继承"
HandshakeBody --> SimpleEncodable : "实现"
ConfigBody --> PbCallback : "继承"
ConfigBody --> SimpleEncodable : "实现"
ProcessInfoBody --> PbCallback : "继承"
ProcessInfoBody --> SimpleEncodable : "实现"
HandshakeBody --> ConfigBody : "包含"
HandshakeBody --> ProcessInfoBody : "包含"
```

**图示来源**
- [Packet.java](file://client/src/main/java/com/github/dtprj/dongting/net/Packet.java#L15-L35)
- [WritePacket.java](file://client/src/main/java/com/github/dtprj/dongting/net/WritePacket.java#L30-L60)
- [ReadPacket.java](file://client/src/main/java/com/github/dtprj/dongting/net/ReadPacket.java#L15-L25)
- [HandshakeBody.java](file://client/src/main/java/com/github/dtprj/dongting/net/HandshakeBody.java#L15-L45)

### 连接管理分析
连接管理负责客户端与服务器之间的连接建立、维护和断开。

```mermaid
sequenceDiagram
participant Client as "NioClient"
participant Worker as "NioWorker"
participant Server as "NioServer"
participant Peer as "Peer"
Client->>Worker : connect(Peer, DtTime)
Worker->>Worker : doConnect()
Worker->>Peer : 标记为connecting
Worker->>Channel : connect(addr)
Worker->>Channel : register(OP_CONNECT)
Channel->>Worker : isConnectable()
Worker->>Worker : whenConnected()
Worker->>Worker : initNewChannel()
Worker->>Worker : sendHandshake()
Worker->>Server : 发送握手请求
Server->>Server : 处理握手
Server->>Worker : 返回握手响应
Worker->>Worker : handshakeSuccess()
Worker->>Peer : 标记为connected
Worker->>Client : 连接完成
```

**图示来源**
- [NioClient.java](file://client/src/main/java/com/github/dtprj/dongting/net/NioClient.java#L150-L180)
- [NioWorker.java](file://client/src/main/java/com/github/dtprj/dongting/net/NioWorker.java#L500-L600)
- [HandshakeProcessor.java](file://client/src/main/java/com/github/dtprj/dongting/net/HandshakeProcessor.java#L15-L45)

## 依赖分析
网络通信层的组件之间存在明确的依赖关系，形成了清晰的层次结构。

```mermaid
graph TD
NioClient --> NioNet
NioServer --> NioNet
NioNet --> NioStatus
NioClient --> NioWorker
NioServer --> NioWorker
NioWorker --> IoWorkerQueue
NioWorker --> WorkerStatus
NioWorker --> DtChannelImpl
NioClient --> Peer
NioClient --> ChannelListener
NioServer --> DtChannel
WritePacket --> Packet
ReadPacket --> Packet
HandshakeProcessor --> ReqProcessor
HandshakeBody --> PbCallback
HandshakeBody --> ConfigBody
HandshakeBody --> ProcessInfoBody
NioClientConfig --> PoolFactory
NioClientConfig --> PerfCallback
NioServerConfig --> PoolFactory
NioServerConfig --> PerfCallback
```

**图示来源**
- [NioClient.java](file://client/src/main/java/com/github/dtprj/dongting/net/NioClient.java#L37-L73)
- [NioServer.java](file://client/src/main/java/com/github/dtprj/dongting/net/NioServer.java#L30-L65)
- [NioWorker.java](file://client/src/main/java/com/github/dtprj/dongting/net/NioWorker.java#L80-L120)

## 性能考虑
网络通信层在设计时充分考虑了性能优化，采用了多种技术来提高吞吐量和降低延迟。

1. **对象池技术**：使用ByteBufferPool和RefBufferFactory来复用缓冲区对象，减少GC压力。
2. **零拷贝**：支持RefBuffer等零拷贝数据结构，避免不必要的数据复制。
3. **批量处理**：通过IoWorkerQueue批量处理I/O事件，减少系统调用次数。
4. **连接复用**：保持长连接，避免频繁的连接建立和断开开销。
5. **异步处理**：采用异步非阻塞I/O模型，提高并发处理能力。
6. **配置优化**：提供多种配置参数，可根据实际场景调整性能。

**性能来源**
- [NioWorker.java](file://client/src/main/java/com/github/dtprj/dongting/net/NioWorker.java#L150-L180)
- [ByteBufferPool.java](file://client/src/main/java/com/github/dtprj/dongting/buf/ByteBufferPool.java#L15-L30)
- [RefBufferFactory.java](file://client/src/main/java/com/github/dtprj/dongting/buf/RefBufferFactory.java#L15-L30)

## 故障排除指南
当网络通信出现问题时，可以按照以下步骤进行排查：

1. **检查连接状态**：使用`getPeers()`方法检查客户端连接状态，确认是否已成功连接。
2. **查看日志信息**：检查日志中的错误信息，特别是连接超时、握手失败等异常。
3. **验证配置参数**：确认NioClientConfig和NioServerConfig中的参数设置是否正确。
4. **检查防火墙设置**：确保服务器端口已开放，防火墙没有阻止连接。
5. **测试网络连通性**：使用ping或telnet测试网络连通性。
6. **监控性能指标**：通过PerfCallback监控关键性能指标，如I/O延迟、吞吐量等。
7. **检查资源使用**：确认系统资源（内存、文件描述符等）是否充足。

**故障排除来源**
- [NioClient.java](file://client/src/main/java/com/github/dtprj/dongting/net/NioClient.java#L250-L280)
- [NioWorker.java](file://client/src/main/java/com/github/dtprj/dongting/net/NioWorker.java#L700-L730)
- [NetException.java](file://client/src/main/java/com/github/dtprj/dongting/net/NetException.java#L15-L25)

## 结论
Dongting的网络通信层基于Java NIO实现了高性能、高可靠性的网络I/O处理。通过NioClient和NioServer的协同工作，结合NioWorker的多线程模型，实现了高效的连接管理和数据传输。握手机制确保了连接的安全性和兼容性，而灵活的配置选项和性能优化技术则满足了不同应用场景的需求。该网络层为上层的RAFT和KV逻辑提供了稳定可靠的通信基础，是整个系统的重要组成部分。