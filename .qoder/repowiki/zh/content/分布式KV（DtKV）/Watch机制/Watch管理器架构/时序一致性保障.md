# 时序一致性保障：ServerWatchManager 的 epoch 机制详解

<cite>
**本文档引用的文件**
- [ServerWatchManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/ServerWatchManager.java)
- [ServerWatchManagerTest.java](file://server/src/test/java/com/github/dtprj/dongting/dtkv/server/ServerWatchManagerTest.java)
- [WatchProcessor.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/WatchProcessor.java)
- [WatchNotifyReq.java](file://client/src/main/java/com/github/dtprj/dongting/dtkv/WatchNotifyReq.java)
- [WatchNotify.java](file://client/src/main/java/com/github/dtprj/dongting/dtkv/WatchNotify.java)
- [README.md](file://README.md)
</cite>

## 目录
1. [引言](#引言)
2. [项目结构概览](#项目结构概览)
3. [核心组件分析](#核心组件分析)
4. [epoch 机制架构](#epoch-机制架构)
5. [详细组件分析](#详细组件分析)
6. [时序一致性保障机制](#时序一致性保障机制)
7. [具体场景示例](#具体场景示例)
8. [性能考虑](#性能考虑)
9. [故障排除指南](#故障排除指南)
10. [结论](#结论)

## 引言

Dongting 是一个高性能的分布式系统引擎，集成了 RAFT 共识算法、配置服务器、消息队列和底层 RPC 功能。在这样的分布式环境中，确保跨 Fiber 调度的时序一致性是一个关键挑战。ServerWatchManager 通过精心设计的 epoch 机制，有效地解决了这一问题。

本文档深入分析 ServerWatchManager 如何通过 epoch 机制保障跨 Fiber 调度的时序一致性，重点说明 reset 方法在 Raft 角色变更或配置重置时递增 epoch 的必要性，以及 processNotifyResult 中 epoch != requestEpoch 检查如何防止过期响应造成的状态错乱。

## 项目结构概览

Dongting 项目采用模块化架构，主要包含以下核心模块：

```mermaid
graph TB
subgraph "核心模块"
Server[Server 模块]
Client[Client 模块]
Benchmark[Benchmark 模块]
Demos[Demos 模块]
end
subgraph "ServerWatchManager 架构"
SWM[ServerWatchManager]
CW[ChannelWatch]
CI[ChannelInfo]
WH[WatchHolder]
end
subgraph "核心功能"
Epoch[Epoch 机制]
Notify[通知机制]
Retry[重试机制]
Dispatch[分发机制]
end
Server --> SWM
SWM --> CW
SWM --> CI
SWM --> WH
SWM --> Epoch
SWM --> Notify
SWM --> Retry
SWM --> Dispatch
```

**图表来源**
- [ServerWatchManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/ServerWatchManager.java#L46-L70)

**章节来源**
- [README.md](file://README.md#L1-L50)

## 核心组件分析

### ServerWatchManager 基础架构

ServerWatchManager 是一个抽象类，负责管理所有与观察者模式相关的操作。它维护了多个关键的数据结构：

```mermaid
classDiagram
class ServerWatchManager {
-IdentityHashMap~DtChannel,ChannelInfo~ channelInfoMap
-LinkedHashSet~ChannelInfo~ needNotifyChannels
-PriorityQueue~ChannelInfo~ retryQueue
-int epoch
-Timestamp ts
-KvConfig config
+reset() void
+addOrUpdateActiveQueue(ChannelInfo) void
+removeByChannel(DtChannel) void
+dispatch() boolean
+processNotifyResult(...) void
+sync(...) void
}
class ChannelInfo {
+DtChannel channel
+HashMap~ByteArray,ChannelWatch~ watches
+boolean pending
+long lastNotifyNanos
+long lastActiveNanos
+LinkedHashSet~ChannelWatch~ needNotify
+long retryNanos
+int failCount
+boolean remove
+addNeedNotify(ChannelWatch) void
}
class ChannelWatch {
+WatchHolder watchHolder
+ChannelInfo channelInfo
+long notifiedIndex
+long notifiedIndexPending
+boolean pending
+boolean removed
+ChannelWatch(WatchHolder, ChannelInfo, long)
}
class WatchHolder {
+HashSet~ChannelWatch~ watches
+ByteArray key
+KvNodeHolder nodeHolder
+WatchHolder parentWatchHolder
+long lastRemoveIndex
+HashMap~ByteArray,WatchHolder~ children
+boolean waitingDispatch
+isNoUse() boolean
+getChild(ByteArray) WatchHolder
+addChild(ByteArray, WatchHolder) void
+removeChild(ByteArray) void
}
ServerWatchManager --> ChannelInfo : "管理"
ServerWatchManager --> WatchHolder : "持有"
ChannelInfo --> ChannelWatch : "包含"
ChannelWatch --> WatchHolder : "关联"
WatchHolder --> ChannelWatch : "监控"
```

**图表来源**
- [ServerWatchManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/ServerWatchManager.java#L46-L70)
- [ServerWatchManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/ServerWatchManager.java#L570-L629)
- [ServerWatchManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/ServerWatchManager.java#L630-L680)

**章节来源**
- [ServerWatchManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/ServerWatchManager.java#L46-L117)

## epoch 机制架构

### epoch 的核心作用

epoch 机制是 ServerWatchManager 实现时序一致性的核心。它通过以下方式工作：

```mermaid
sequenceDiagram
participant Client as 客户端
participant Manager as ServerWatchManager
participant Fiber as Fiber 线程
participant Network as 网络层
Note over Manager : 初始 epoch = 0
Manager->>Manager : 同步数据更新
Manager->>Manager : 创建通知请求(epoch=0)
Manager->>Network : 发送请求到客户端
Network-->>Manager : 网络延迟或乱序
Manager->>Manager : reset() 调用
Manager->>Manager : epoch++ (epoch=1)
Manager->>Manager : 清空旧状态
Manager->>Manager : 新的数据更新
Manager->>Manager : 创建新的通知请求(epoch=1)
Manager->>Network : 发送新请求
Note over Manager : processNotifyResult(epoch=0)
Manager->>Manager : 检查 epoch != requestEpoch
Manager->>Manager : 忽略过期响应
Note over Manager : processNotifyResult(epoch=1)
Manager->>Manager : 处理新响应
Manager->>Manager : 更新 notifiedIndex
```

**图表来源**
- [ServerWatchManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/ServerWatchManager.java#L85-L92)
- [ServerWatchManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/ServerWatchManager.java#L374-L405)

### epoch 递增的触发时机

reset 方法在以下情况下递增 epoch：

1. **Raft 角色变更**：当节点成为新的领导者或失去领导者角色时
2. **配置重置**：当系统配置发生变化需要重新初始化时
3. **状态不一致检测**：当检测到状态不一致需要强制同步时

```java
// reset 方法的核心逻辑
public void reset() {
    epoch++;  // 关键：递增 epoch
    needNotifyChannels.clear();
    channelInfoMap.clear();
    retryQueue.clear();
    activeQueueHead = null;
    activeQueueTail = null;
}
```

**章节来源**
- [ServerWatchManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/ServerWatchManager.java#L85-L92)

## 详细组件分析

### ChannelWatch 的双索引机制

ChannelWatch 使用两个关键字段来跟踪通知状态：

```mermaid
classDiagram
class ChannelWatch {
+long notifiedIndex
+long notifiedIndexPending
+boolean pending
+boolean removed
+ChannelWatch(WatchHolder, ChannelInfo, long)
<<method>>
updateNotifiedIndex() void
checkNotificationNeeded() boolean
}
note for ChannelWatch "notifiedIndex : 已确认的通知索引\nnotifiedIndexPending : 待确认的通知索引"
```

**图表来源**
- [ServerWatchManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/ServerWatchManager.java#L630-L680)

#### notifiedIndex 字段

- **含义**：表示客户端已经成功接收并确认的通知的最大索引值
- **用途**：用于过滤重复通知，避免向客户端发送已经确认过的变更
- **更新时机**：只有在客户端成功响应后才会更新

#### notifiedIndexPending 字段

- **含义**：表示正在等待客户端确认的通知索引
- **用途**：在通知发送过程中临时存储待确认的索引值
- **更新时机**：在 createNotify 方法中设置为最新的更新索引

### processNotifyResult 中的 epoch 检查

processNotifyResult 方法是 epoch 机制的核心验证点：

```mermaid
flowchart TD
Start([开始处理通知结果]) --> CheckEpoch{"epoch != requestEpoch?"}
CheckEpoch --> |是| Return[直接返回，忽略响应]
CheckEpoch --> |否| MarkPending[标记 pending=false]
MarkPending --> CheckError{"是否有异常?"}
CheckError --> |是| LogError[记录错误日志]
CheckError --> |否| CheckSuccess{"业务码是否成功?"}
LogError --> CheckErrorCode{"错误码类型?"}
CheckErrorCode --> |CLIENT_ERROR| RemoveChannel[移除通道]
CheckErrorCode --> |STOPPING| RemoveChannel
CheckErrorCode --> |COMMAND_NOT_SUPPORT| RemoveChannel
CheckErrorCode --> |其他| RetryChannel[重试通道]
CheckSuccess --> |否| LogError2[记录错误日志]
CheckSuccess --> |是| ProcessResults[处理结果数组]
ProcessResults --> CheckResult{"每个结果是否成功?"}
CheckResult --> |有失败| RetryChannel
CheckResult --> |全部成功| UpdateIndex[更新 notifiedIndex]
UpdateIndex --> CheckFireNext{"是否需要发送下一个?"}
CheckFireNext --> |是| SendNext[发送下一个通知]
CheckFireNext --> |否| AddToNotify[添加到待通知队列]
RemoveChannel --> End([结束])
RetryChannel --> End
SendNext --> End
AddToNotify --> End
Return --> End
LogError2 --> End
```

**图表来源**
- [ServerWatchManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/ServerWatchManager.java#L374-L405)

**章节来源**
- [ServerWatchManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/ServerWatchManager.java#L374-L405)

## 时序一致性保障机制

### epoch 机制的工作原理

epoch 机制通过以下步骤确保时序一致性：

1. **epoch 初始化**：每次重置时递增 epoch 计数器
2. **请求携带 epoch**：所有通知请求都携带当前 epoch 值
3. **响应验证 epoch**：服务端严格检查响应中的 epoch 是否匹配
4. **过期响应过滤**：不匹配的 epoch 响应被直接丢弃

```mermaid
sequenceDiagram
participant S as Server
participant C1 as Client 1
participant C2 as Client 2
participant W as WatchManager
Note over S,W : 初始状态 : epoch=0
S->>W : 数据更新
W->>C1 : 发送通知请求(epoch=0)
W->>C2 : 发送通知请求(epoch=0)
Note over S : reset() 调用
S->>W : reset()
W->>W : epoch++ (epoch=1)
W->>W : 清空旧状态
S->>W : 新的数据更新
W->>C1 : 发送新的通知请求(epoch=1)
W->>C2 : 发送新的通知请求(epoch=1)
Note over C1,C2 : 网络延迟导致响应乱序
C1-->>W : 过期响应 (epoch=0)
C2-->>W : 新响应 (epoch=1)
W->>W : 检查 epoch!=requestEpoch
W->>W : 忽略过期响应
W->>W : 处理新响应
W->>W : 更新 notifiedIndex
```

**图表来源**
- [ServerWatchManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/ServerWatchManager.java#L374-L405)
- [ServerWatchManagerTest.java](file://server/src/test/java/com/github/dtprj/dongting/dtkv/server/ServerWatchManagerTest.java#L535-L550)

### 双索引协同工作机制

notifiedIndex 和 notifiedIndexPending 字段与 epoch 机制协同工作：

```mermaid
stateDiagram-v2
[*] --> Idle : 初始状态
Idle --> CreatingNotify : createNotify()
CreatingNotify --> SettingPending : 设置 notifiedIndexPending
SettingPending --> SendingRequest : 发送请求(epoch=当前值)
SendingRequest --> WaitingResponse : 等待响应
WaitingResponse --> ProcessingResponse : 收到响应
ProcessingResponse --> CheckingEpoch : 检查 epoch
CheckingEpoch --> IgnoringOld : epoch 不匹配
CheckingEpoch --> UpdatingIndex : epoch 匹配
IgnoringOld --> [*]
UpdatingIndex --> UpdatingNotified : 更新 notifiedIndex
UpdatingNotified --> [*]
```

**图表来源**
- [ServerWatchManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/ServerWatchManager.java#L345-L372)
- [ServerWatchManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/ServerWatchManager.java#L374-L405)

**章节来源**
- [ServerWatchManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/ServerWatchManager.java#L345-L405)

## 具体场景示例

### 场景一：网络延迟导致的响应乱序

假设存在以下网络延迟情况：

```mermaid
sequenceDiagram
participant T1 as 时间点 1 (epoch=0)
participant T2 as 时间点 2 (epoch=0)
participant T3 as 时间点 3 (epoch=1)
participant T4 as 时间点 4 (epoch=1)
Note over T1,T4 : 场景描述 : 网络延迟导致响应乱序
T1->>T2 : 数据更新 1
T2->>T3 : 发送通知请求 1 (epoch=0)
T3->>T4 : 网络延迟
T4->>T1 : reset() 调用 (epoch=1)
T1->>T2 : 数据更新 2
T2->>T3 : 发送通知请求 2 (epoch=1)
T3->>T4 : 网络延迟
Note over T4 : 响应到达顺序 : 请求 1 -> 请求 2
T4->>T4 : 处理请求 1 (epoch=0)
T4->>T4 : 检查 epoch!=requestEpoch
T4->>T4 : 忽略过期响应
T4->>T4 : 处理请求 2 (epoch=1)
T4->>T4 : 正常处理新响应
```

**图表来源**
- [ServerWatchManagerTest.java](file://server/src/test/java/com/github/dtprj/dongting/dtkv/server/ServerWatchManagerTest.java#L535-L550)

### 场景二：Raft 领导者变更

当 Raft 集群发生领导者变更时：

```mermaid
sequenceDiagram
participant L1 as 当前领导者
participant L2 as 新领导者
participant C as 客户端
Note over L1,L2 : 领导者变更过程
L1->>L1 : 准备切换
L1->>L1 : reset() 调用
L1->>L1 : epoch++ (epoch=1)
L1->>L1 : 清空旧状态
Note over L1,L2 : 新领导者接管
L2->>L2 : 开始正常工作
L2->>L2 : epoch=1
L2->>C : 发送通知请求 (epoch=1)
C->>L2 : 响应 (epoch=1)
L2->>L2 : 正常处理响应
Note over L1 : 过期响应到达
L1->>L1 : 收到响应 (epoch=0)
L1->>L1 : 检查 epoch!=requestEpoch
L1->>L1 : 忽略过期响应
```

**图表来源**
- [ServerWatchManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/ServerWatchManager.java#L85-L92)

### 场景三：配置重置后的状态同步

当系统进行配置重置时：

```mermaid
flowchart TD
Start([开始配置重置]) --> ResetCall[调用 reset()]
ResetCall --> IncrementEpoch[epoch++]
IncrementEpoch --> ClearState[清空所有状态]
ClearState --> RebuildStructure[重建内部结构]
RebuildStructure --> NewEpoch[epoch=新值]
NewEpoch --> Ready[准备接受新请求]
Ready --> NewRequest[新通知请求]
NewRequest --> CheckEpoch{"epoch 匹配?"}
CheckEpoch --> |是| Process[正常处理]
CheckEpoch --> |否| Ignore[忽略响应]
Process --> UpdateIndex[更新 notifiedIndex]
UpdateIndex --> Complete[完成]
Ignore --> Complete
```

**图表来源**
- [ServerWatchManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/ServerWatchManager.java#L85-L92)

**章节来源**
- [ServerWatchManagerTest.java](file://server/src/test/java/com/github/dtprj/dongting/dtkv/server/ServerWatchManagerTest.java#L535-L550)

## 性能考虑

### epoch 机制的性能影响

epoch 机制对性能的影响主要体现在以下几个方面：

1. **内存占用**：每个 ChannelWatch 额外维护两个 long 类型字段
2. **CPU 开销**：每次处理响应都需要进行 epoch 检查
3. **网络开销**：通知请求中携带 epoch 信息

### 优化策略

为了最小化性能影响，Dongting 采用了以下优化策略：

1. **轻量级检查**：epoch 检查是一个简单的整数比较操作
2. **早期退出**：发现 epoch 不匹配立即返回，避免后续处理
3. **批量处理**：支持批量通知请求，减少网络往返次数

```java
// 优化的 epoch 检查逻辑
public void processNotifyResult(ChannelInfo ci, ArrayList<ChannelWatch> watches,
                                ReadPacket<WatchNotifyRespCallback> result,
                                Throwable ex, int requestEpoch, boolean fireNext) {
    try {
        if (epoch != requestEpoch) {
            return; // 早期退出，避免后续处理
        }
        // 正常处理逻辑...
    } catch (Exception e) {
        log.error("", e);
    }
}
```

## 故障排除指南

### 常见问题及解决方案

#### 问题 1：epoch 不匹配导致的响应被忽略

**症状**：
- 客户端没有收到预期的通知
- 日志中出现 epoch 不匹配的警告

**诊断步骤**：
1. 检查 epoch 值的变化历史
2. 分析网络延迟和乱序情况
3. 验证 reset 调用的频率和时机

**解决方案**：
```java
// 在调试模式下打印 epoch 信息
if (epoch != requestEpoch) {
    log.warn("Ignoring response with old epoch. Current: {}, Received: {}", 
             epoch, requestEpoch);
    return;
}
```

#### 问题 2：状态不一致导致的重复通知

**症状**：
- 客户端收到重复的通知
- notifiedIndex 更新异常

**诊断步骤**：
1. 检查 notifiedIndex 和 notifiedIndexPending 的值
2. 验证 epoch 机制是否正常工作
3. 分析通知发送和处理的时序

**解决方案**：
```java
// 确保 notifiedIndex 只在成功响应后更新
if (bizCode == KvCodes.SUCCESS) {
    w.notifiedIndex = w.notifiedIndexPending;
    // 添加调试日志
    log.debug("Updated notifiedIndex for watch: {} -> {}", 
              w.notifiedIndex, w.notifiedIndexPending);
}
```

**章节来源**
- [ServerWatchManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/ServerWatchManager.java#L374-L405)

## 结论

ServerWatchManager 通过精心设计的 epoch 机制，成功解决了跨 Fiber 调度环境下的时序一致性问题。该机制的核心优势包括：

1. **简单高效**：基于整数计数的 epoch 机制，实现简单且性能优异
2. **容错性强**：能够有效处理网络延迟、响应乱序等各种异常情况
3. **可扩展性好**：支持动态配置重置和 Raft 角色变更
4. **状态安全**：通过严格的 epoch 检查，确保状态的一致性和正确性

epoch 机制与 ChannelWatch 的双索引协同工作，形成了一个完整的时序一致性保障体系。这种设计不仅保证了系统的可靠性，还保持了良好的性能特征，是分布式系统设计中的优秀实践案例。

通过深入理解 epoch 机制的工作原理和应用场景，开发者可以更好地利用 ServerWatchManager 提供的功能，构建稳定可靠的分布式应用程序。