# TTL过期回调执行流程

<cite>
**本文档引用的文件**
- [TtlManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/TtlManager.java)
- [DtKVExecutor.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/DtKVExecutor.java)
- [DtKV.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/DtKV.java)
- [KvImpl.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/KvImpl.java)
- [TtlManagerTest.java](file://server/src/test/java/com/github/dtprj/dongting/dtkv/server/TtlManagerTest.java)
- [TtlDemoClient.java](file://demos/src/main/java/com/github/dtprj/dongting/demos/ttl/TtlDemoClient.java)
- [TtlDemoServer.java](file://demos/src/main/java/com/github/dtprj/dongting/demos/ttl/TtlDemoServer.java)
- [DemoKvServerBase.java](file://demos/src/main/java/com/github/dtprj/dongting/demos/base/DemoKvServerBase.java)
</cite>

## 目录
1. [概述](#概述)
2. [核心组件架构](#核心组件架构)
3. [TTL回调执行流程](#ttl回调执行流程)
4. [领导者节点处理机制](#领导者节点处理机制)
5. [异常处理与退避策略](#异常处理与退避策略)
6. [系统一致性保障](#系统一致性保障)
7. [实际应用场景](#实际应用场景)
8. [故障排除指南](#故障排除指南)
9. [总结](#总结)

## 概述

Dongting框架中的TTL（生存时间）过期回调执行流程是一个高度可靠且容错的系统设计，专门用于处理分布式键值存储中的数据过期操作。该系统通过Raft共识算法确保只有领导者节点才能执行过期回调，同时提供了完善的异常处理和退避策略来保证系统的高可用性和数据一致性。

## 核心组件架构

### 系统架构概览

```mermaid
graph TB
subgraph "客户端层"
Client[TTL客户端]
DemoClient[TTL演示客户端]
end
subgraph "服务端层"
RaftServer[Raft服务器]
DtKV[DtKV状态机]
TtlManager[TTL管理器]
DtKVExecutor[DtKV执行器]
end
subgraph "存储层"
KvImpl[KvImpl实现]
MemoryMap[内存映射表]
end
Client --> RaftServer
DemoClient --> RaftServer
RaftServer --> DtKV
DtKV --> TtlManager
TtlManager --> DtKVExecutor
DtKV --> KvImpl
KvImpl --> MemoryMap
TtlManager -.->|expireCallback| KvImpl
```

**图表来源**
- [TtlManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/TtlManager.java#L35-L58)
- [DtKV.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/DtKV.java#L57-L85)

### 关键组件关系图

```mermaid
classDiagram
class TtlManager {
-Timestamp ts
-Consumer~TtlInfo~ expireCallback
+TreeSet~TtlInfo~ ttlQueue
+TreeSet~TtlInfo~ pendingQueue
+TtlTask task
+boolean stop
-RaftRole role
+long defaultDelayNanos
+long retryDelayNanos
+initTtl(raftIndex, key, node, ctx)
+updateTtl(raftIndex, key, node, ctx)
+remove(node)
+roleChange(role)
+retry(ttlInfo, ex)
}
class TtlTask {
+execute() long
+shouldPause() boolean
+shouldStop() boolean
+defaultDelayNanos() long
+signal()
}
class TtlInfo {
+ByteArray key
+long raftIndex
+UUID owner
+long leaderTtlStartMillis
+long ttlMillis
+long expireNanos
+boolean expireFailed
+long lastFailNanos
+compareTo(o) int
}
class DtKVExecutor {
+Timestamp ts
+startDaemonTask(name, task) boolean
+submitTaskInAnyThread(runnable) boolean
+submitTaskInFiberThread(runnable) boolean
}
class DtKV {
+expire(ttlInfo)
+expire(index, key, expectRaftIndex) KvResult
+expireInLock(index, holder) KvResult
}
TtlManager --> TtlTask : "包含"
TtlManager --> TtlInfo : "管理"
TtlTask --|> DtKVExecutor.DtKVExecutorTask : "继承"
TtlManager --> DtKV : "依赖"
DtKV --> TtlManager : "调用"
```

**图表来源**
- [TtlManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/TtlManager.java#L35-L242)
- [DtKVExecutor.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/DtKVExecutor.java#L121-L214)

**章节来源**
- [TtlManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/TtlManager.java#L35-L242)
- [DtKVExecutor.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/DtKVExecutor.java#L121-L214)

## TTL回调执行流程

### 回调调用时机与上下文环境

TTL过期回调的执行遵循严格的时序控制和上下文验证机制：

```mermaid
sequenceDiagram
participant Timer as "定时器"
participant TtlTask as "TTL任务"
participant TtlManager as "TTL管理器"
participant Callback as "过期回调"
participant StateMachine as "状态机"
Timer->>TtlTask : 触发执行
TtlTask->>TtlManager : 检查待过期队列
TtlManager->>TtlManager : 遍历过期元素
loop 对每个过期TtlInfo
TtlManager->>TtlManager : 验证过期时间
alt 已过期
TtlManager->>TtlManager : 移动到待处理队列
TtlManager->>Callback : expireCallback.accept(ttlInfo)
alt 回调成功
TtlManager->>TtlManager : 清除失败标记
else 回调失败
TtlManager->>TtlManager : 设置失败标记
TtlManager->>BugLog : 记录错误日志
TtlManager->>Timer : 返回退避延迟
end
else 未过期
TtlManager->>Timer : 返回剩余等待时间
end
end
TtlTask->>Timer : 返回下次执行时间
```

**图表来源**
- [TtlManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/TtlManager.java#L60-L110)

### 执行方法中的关键逻辑

在`TtlTask.execute()`方法中，回调的调用时机和上下文环境通过以下步骤严格控制：

1. **队列检查与批处理**：系统首先检查`pendingQueue`和`ttlQueue`两个队列的状态
2. **过期时间验证**：对于`ttlQueue`中的每个元素，验证其是否已过期
3. **回调执行**：当元素过期时，立即调用`expireCallback.accept(ttlInfo)`
4. **状态更新**：根据回调执行结果更新元素的失败状态

**章节来源**
- [TtlManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/TtlManager.java#L60-L110)

## 领导者节点处理机制

### shouldPause方法的设计原理

`shouldPause()`方法是确保只有Raft领导者节点处理过期任务的核心机制：

```mermaid
flowchart TD
Start([任务执行开始]) --> CheckRole{"检查角色"}
CheckRole --> |领导者| Continue[继续执行]
CheckRole --> |跟随者/Follower| Pause[暂停执行]
Continue --> CheckQueue{"检查队列"}
Pause --> ReturnDelay[返回最小延迟<br/>至少1ms]
CheckQueue --> |有任务| ExecuteTasks[执行任务]
CheckQueue --> |无任务| ReturnDefault[返回默认延迟<br/>1秒]
ExecuteTasks --> ProcessBatch[批量处理<br/>最多50个任务]
ProcessBatch --> CheckRetry{"检查重试队列"}
CheckRetry --> |有重试任务| RetryBatch[批量重试<br/>最多10个任务]
CheckRetry --> |无重试任务| ReturnDefault
RetryBatch --> ReturnDefault
ReturnDelay --> End([结束])
ReturnDefault --> End
```

**图表来源**
- [TtlManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/TtlManager.java#L112-L115)

### 设计原理分析

1. **Raft角色同步**：通过`roleChange()`方法同步Raft角色变化
2. **队列迁移**：从`pendingQueue`迁移到`ttlQueue`，确保一致性
3. **信号通知**：通过`task.signal()`触发重新调度
4. **暂停机制**：跟随者节点自动暂停执行，避免并发问题

**章节来源**
- [TtlManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/TtlManager.java#L112-L115)
- [TtlManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/TtlManager.java#L230-L242)

## 异常处理与退避策略

### 异常捕获机制的工作方式

系统采用全面的异常捕获机制来确保即使回调失败也不会影响整个系统的稳定性：

```mermaid
flowchart TD
Start([回调执行开始]) --> TryBlock[try块执行]
TryBlock --> Success{执行成功?}
Success --> |是| ClearFlag[清除失败标志]
Success --> |否| CatchBlock[catch Throwable块]
CatchBlock --> SetFailed[设置expireFailed=true]
SetFailed --> RecordTime[记录lastFailNanos]
RecordTime --> LogError[BugLog.log(ex)]
LogError --> ReturnDelay[返回默认延迟]
ClearFlag --> ReturnNormal[返回正常延迟]
ReturnDelay --> End([结束])
ReturnNormal --> End
```

**图表来源**
- [TtlManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/TtlManager.java#L91-L105)

### 退避策略详解

系统实现了两层退避策略来处理回调失败的情况：

1. **默认退避策略**：
   - 失败后返回`defaultDelayNanos`（1秒）
   - 适用于一般性异常情况

2. **重试退避策略**：
   - 重试前检查`retryDelayNanos`间隔
   - 只有超过间隔时间才重新尝试
   - 最大重试批次限制为10个

**章节来源**
- [TtlManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/TtlManager.java#L91-L105)
- [TtlManager.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/TtlManager.java#L43-L46)

## 系统一致性保障

### 回调失败对系统一致性的影响

当TTL过期回调失败时，系统通过以下机制确保数据一致性：

```mermaid
stateDiagram-v2
[*] --> 正常状态
正常状态 --> 失败状态 : 回调异常
失败状态 --> 重试状态 : 超过重试间隔
失败状态 --> 正常状态 : 未超过重试间隔
重试状态 --> 正常状态 : 重试成功
重试状态 --> 失败状态 : 重试失败
note right of 正常状态 : 数据保持一致<br/>expireFailed=false<br/>lastFailNanos=0
note right of 失败状态 : 数据可能不一致<br/>expireFailed=true<br/>记录失败时间
note right of 重试状态 : 尝试恢复一致性<br/>等待重试间隔
```

### 应对措施

1. **幂等性保证**：回调函数必须是幂等的，支持重复执行
2. **索引验证**：通过`expectRaftIndex`参数防止过期操作被重复执行
3. **状态监控**：通过`BugLog`记录所有异常，便于问题追踪
4. **优雅降级**：即使部分回调失败，系统仍能继续运行

**章节来源**
- [DtKV.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/DtKV.java#L375-L400)
- [KvImpl.java](file://server/src/main/java/com/github/dtprj/dongting/dtkv/server/KvImpl.java#L810-L836)

## 实际应用场景

### TTL演示客户端使用示例

通过TTL演示客户端可以直观地看到过期回调的执行效果：

```java
// 客户端示例代码
System.out.println("put tempKey1 with value tempValue1");
long ttlMillis = 3000; // 3秒TTL
kvClient.putTemp(GROUP_ID, "tempKey1".getBytes(), "tempValue1".getBytes(), ttlMillis);

// 等待一段时间后获取
System.out.println("sleep 5000 millis");
Thread.sleep(5000);

// TTL过期后应该获取不到数据
KvNode node = kvClient.get(GROUP_ID, "tempKey1".getBytes());
System.out.println("get tempKey1, value=" + (node == null ? "null" : new String(node.data)));
```

### 服务器端启动流程

```mermaid
sequenceDiagram
participant Main as "主程序"
participant Server as "Raft服务器"
participant Factory as "状态机工厂"
participant DtKV as "DtKV实例"
participant TtlManager as "TTL管理器"
Main->>Server : 创建Raft服务器
Server->>Factory : 注册状态机工厂
Factory->>DtKV : 创建DtKV实例
DtKV->>TtlManager : 初始化TTL管理器
TtlManager->>TtlManager : 启动TTL任务
Server->>Server : 启动网络服务
Server->>Main : 服务器就绪
```

**图表来源**
- [TtlDemoServer.java](file://demos/src/main/java/com/github/dtprj/dongting/demos/ttl/TtlDemoServer.java#L25-L32)
- [DemoKvServerBase.java](file://demos/src/main/java/com/github/dtprj/dongting/demos/base/DemoKvServerBase.java#L45-L83)

**章节来源**
- [TtlDemoClient.java](file://demos/src/main/java/com/github/dtprj/dongting/demos/ttl/TtlDemoClient.java#L30-L57)
- [TtlDemoServer.java](file://demos/src/main/java/com/github/dtprj/dongting/demos/ttl/TtlDemoServer.java#L25-L32)

## 故障排除指南

### 常见问题诊断

1. **回调执行延迟**
   - 检查`defaultDelayNanos`配置
   - 验证系统负载情况
   - 查看`BugLog`中的异常信息

2. **过期数据残留**
   - 确认`expireCallback`是否正确实现
   - 检查`expectRaftIndex`匹配情况
   - 验证Raft角色状态

3. **系统性能问题**
   - 监控批处理大小（MAX_EXPIRE_BATCH）
   - 调整重试间隔（retryDelayNanos）
   - 分析内存使用情况

### 调试技巧

- 使用`BugLog`查看详细的异常堆栈
- 监控`ttlQueue`和`pendingQueue`的大小变化
- 在测试环境中模拟各种异常场景

**章节来源**
- [TtlManagerTest.java](file://server/src/test/java/com/github/dtprj/dongting/dtkv/server/TtlManagerTest.java#L197-L233)

## 总结

Dongting框架的TTL过期回调执行流程是一个设计精良的分布式系统组件，具有以下特点：

1. **高可靠性**：通过Raft领导者选举确保一致性
2. **容错性强**：完善的异常处理和退避策略
3. **性能优化**：批处理和队列管理提升效率
4. **易于调试**：全面的日志记录和状态监控

该系统通过精心设计的回调机制，在保证数据一致性的同时，提供了良好的可维护性和可观测性，是构建分布式键值存储系统的重要基础设施。