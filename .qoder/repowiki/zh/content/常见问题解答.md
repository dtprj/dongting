# 常见问题解答（FAQ）

<cite>
**本文档中引用的文件**
- [README.md](file://README.md)
- [2024_07_09_第二点阶段性进展.md](file://devlogs/2024_07_09_第二点阶段性进展.md)
- [2024_07_16_3000行代码实现fiber.md](file://devlogs/2024_07_16_3000行代码实现fiber.md)
- [2024_07_26_raft算法的工程实现秘笈.md](file://devlogs/2024_07_26_raft算法的工程实现秘笈.md)
- [DemoClient.java](file://demos/src/main/java/com/github/dtprj/dongting/demos/cluster/DemoClient.java)
- [DemoServer1.java](file://demos/src/main/java/com/github/dtprj/dongting/demos/cluster/DemoServer1.java)
- [ChangeLeader.java](file://demos/src/main/java/com/github/dtprj/dongting/demos/cluster/ChangeLeader.java)
- [FiberChannel.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/FiberChannel.java)
- [NetTimeoutException.java](file://client/src/main/java/com/github/dtprj/dongting/net/NetTimeoutException.java)
- [SimpleByteBufferPool.java](file://client/src/main/java/com/github/dtprj/dongting/buf/SimpleByteBufferPool.java)
- [RaftTimeoutException.java](file://client/src/main/java/com/github/dtprj/dongting/raft/RaftTimeoutException.java)
- [FiberException.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/FiberException.java)
</cite>

## 目录
1. [概述](#概述)
2. [节点无法选举Leader](#节点无法选举leader)
3. [Fiber出现死锁如何排查](#fiber出现死锁如何排查)
4. [对象池耗尽怎么办](#对象池耗尽怎么办)
5. [网络连接频繁超时如何处理](#网络连接频繁超时如何处理)
6. [Raft集群性能优化](#raft集群性能优化)
7. [Fiber使用最佳实践](#fiber使用最佳实践)
8. [故障排除指南](#故障排除指南)
9. [总结](#总结)

## 概述

Dongting是一个高性能的分布式系统引擎，集成了RAFT共识算法、配置服务器、消息队列和底层RPC功能。本文档收集并回答用户在使用过程中最常见的问题，帮助用户快速解决遇到的障碍。

## 节点无法选举Leader

### 问题描述

在RAFT集群中，节点无法成功选举Leader，导致集群无法正常工作。

### 可能原因分析

1. **网络分区问题**：集群中的节点之间存在网络分区，导致无法形成多数派
2. **配置错误**：节点配置不一致，导致选举失败
3. **时间同步问题**：系统时间不同步，影响选举超时判断
4. **硬件故障**：部分节点硬件故障，无法正常参与选举

### 解决方案

#### 1. 检查网络连通性

```bash
# 检查节点间网络连通性
ping <node-ip>
telnet <node-ip> <port>

# 检查防火墙设置
iptables -L
```

#### 2. 验证配置一致性

```java
// 使用raft ping验证配置
AdminRaftClient adminClient = new AdminRaftClient();
adminClient.start();
adminClient.clientAddNode(servers);
adminClient.clientAddOrUpdateGroup(GROUP_ID, new int[]{1, 2, 3});

// 检查配置是否一致
GroupInfo groupInfo = adminClient.fetchGroupInfo(GROUP_ID).get();
```

#### 3. 时间同步检查

```bash
# 检查系统时间
date

# 启动NTP同步
sudo systemctl start ntp
sudo systemctl enable ntp
```

#### 4. 查看日志分析

```java
// 启用详细日志
Logger logger = LoggerFactory.getLogger(VoteManager.class);
logger.setLevel(Level.INFO);

// 关注关键日志信息
// elect timer timeout
// write not finished
// apply not finished
```

**章节来源**
- [2024_07_26_raft算法的工程实现秘笈.md](file://devlogs/2024_07_26_raft算法的工程实现秘笈.md#L288-L306)

## Fiber出现死锁如何排查

### 问题描述

Fiber程序出现死锁，导致程序无法继续执行。

### 可能原因分析

1. **循环等待**：多个Fiber相互等待对方释放资源
2. **资源竞争**：多个Fiber竞争同一资源
3. **异常处理不当**：异常未正确处理导致Fiber无法恢复
4. **超时设置不合理**：等待超时时间设置过短

### 排查步骤

#### 1. 启用Fiber调试信息

```java
// 在FiberGroup中启用调试
FiberGroup fiberGroup = new FiberGroup("debugGroup", dispatcher);
fiberGroup.enableDebug();

// 查看当前运行的Fiber
fiberGroup.dumpRunningFibers();
```

#### 2. 分析调用栈

```java
// FiberException包含虚拟栈信息
try {
    // Fiber操作
} catch (FiberException e) {
    // 打印完整的调用栈
    e.printStackTrace();
    
    // 获取虚拟栈信息
    for (Throwable suppressed : e.getSuppressed()) {
        if (suppressed instanceof FiberVirtualException) {
            suppressed.printStackTrace();
        }
    }
}
```

#### 3. 检查资源使用

```java
// 检查FiberChannel状态
FiberChannel<Object> channel = fiberGroup.newChannel();
System.out.println("Channel size: " + channel.size());

// 检查FiberLock状态
FiberLock lock = fiberGroup.newLock();
System.out.println("Lock held: " + lock.isHeldByCurrentFiber());
```

### 解决方案

#### 1. 避免循环等待

```java
// 错误示例：可能导致死锁
FiberLock lock1 = group.newLock();
FiberLock lock2 = group.newLock();

// 正确做法：始终以相同的顺序获取锁
private void acquireLocks(FiberLock lock1, FiberLock lock2) {
    // 总是以固定的顺序获取锁
    if (lock1.hashCode() < lock2.hashCode()) {
        lock1.lock();
        lock2.lock();
    } else {
        lock2.lock();
        lock1.lock();
    }
}
```

#### 2. 设置合理的超时

```java
// 使用超时避免无限等待
try {
    FrameCallResult result = channel.take(5000, this::resume);
    // 处理结果
} catch (FiberTimeoutException e) {
    // 处理超时情况
    log.warn("Channel take timeout", e);
}
```

**章节来源**
- [2024_07_16_3000行代码实现fiber.md](file://devlogs/2024_07_16_3000行代码实现fiber.md#L200-L302)
- [FiberException.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/FiberException.java#L30-L84)

## 对象池耗尽怎么办

### 问题描述

缓冲池或对象池耗尽，导致应用程序性能下降或出现异常。

### 可能原因分析

1. **内存泄漏**：对象未正确释放
2. **池大小不足**：池配置过小
3. **高并发场景**：短时间内大量请求
4. **长时间持有对象**：对象被长时间持有不释放

### 解决方案

#### 1. 监控池使用情况

```java
// 获取缓冲池统计信息
SimpleByteBufferPool pool = new SimpleByteBufferPool(config);
String stats = pool.formatStat();
System.out.println(stats);

// 关注关键指标
// borrow命中率
// release命中率
// borrow too small
// borrow too large
```

#### 2. 调整池配置

```java
// 创建自定义缓冲池配置
SimpleByteBufferPoolConfig config = new SimpleByteBufferPoolConfig();
config.setBufSizes(new int[]{1024, 2048, 4096, 8192});
config.setMaxCount(new int[]{2048, 1024, 512, 256});
config.setMinCount(new int[]{32, 16, 8, 4});
config.setTimeoutMillis(60000); // 60秒超时

SimpleByteBufferPool pool = new SimpleByteBufferPool(config);
```

#### 3. 实现优雅的资源管理

```java
// 使用try-with-resources确保资源释放
try (RefBuffer buffer = pool.borrowRefBuffer(size)) {
    // 使用缓冲区
    processBuffer(buffer);
} // 自动释放缓冲区

// 或手动释放
RefBuffer buffer = pool.borrowRefBuffer(size);
try {
    // 使用缓冲区
    processBuffer(buffer);
} finally {
    pool.release(buffer);
}
```

#### 4. 清理过期对象

```java
// 定期清理过期对象
ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
scheduler.scheduleAtFixedRate(() -> {
    pool.clean();
}, 0, 10, TimeUnit.MINUTES);
```

### 性能优化建议

1. **合理设置阈值**：threshold参数控制直接分配和池分配的界限
2. **监控命中率**：确保borrow和release的命中率在合理范围内
3. **调整超时时间**：根据业务特点调整对象回收超时时间
4. **定期清理**：避免内存泄漏导致池耗尽

**章节来源**
- [SimpleByteBufferPool.java](file://client/src/main/java/com/github/dtprj/dongting/buf/SimpleByteBufferPool.java#L30-L344)

## 网络连接频繁超时如何处理

### 问题描述

网络连接频繁超时，影响系统正常运行。

### 可能原因分析

1. **网络延迟过高**：网络质量差
2. **连接池配置不当**：连接数不足或超时时间过短
3. **服务器负载过高**：处理能力不足
4. **防火墙或代理问题**：中间设备干扰

### 解决方案

#### 1. 调整连接配置

```java
// 配置客户端连接参数
NioClientConfig clientConfig = new NioClientConfig();
clientConfig.connectTimeoutMillis = 5000; // 连接超时5秒
clientConfig.readTimeoutMillis = 10000; // 读取超时10秒
clientConfig.writeTimeoutMillis = 10000; // 写入超时10秒
clientConfig.connectRetryIntervals = new int[]{100, 500, 1000}; // 重试间隔
```

#### 2. 实现自动重连机制

```java
// 实现连接重试逻辑
public CompletableFuture<DtChannel> connectWithRetry(Peer peer, int maxRetries) {
    AtomicInteger retries = new AtomicInteger(0);
    
    return CompletableFuture.supplyAsync(() -> {
        while (retries.get() < maxRetries) {
            try {
                return client.connect(peer).get();
            } catch (ExecutionException e) {
                if (e.getCause() instanceof NetTimeoutException) {
                    int retryDelay = Math.min(1000 * retries.incrementAndGet(), 5000);
                    Thread.sleep(retryDelay);
                    continue;
                }
                throw new RuntimeException(e);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new RuntimeException(e);
            }
        }
        throw new RuntimeException("Max retries reached");
    });
}
```

#### 3. 监控网络状况

```java
// 监控连接状态
Peer peer = client.addPeer(new HostPort("127.0.0.1", 8888)).get();
while (true) {
    System.out.println("Peer status: " + peer.status);
    System.out.println("Connection count: " + peer.connectionCount);
    Thread.sleep(5000);
}
```

#### 4. 优化网络配置

```bash
# 调整TCP参数
echo 'net.core.somaxconn = 1024' >> /etc/sysctl.conf
echo 'net.ipv4.tcp_max_syn_backlog = 1024' >> /etc/sysctl.conf
echo 'net.core.netdev_max_backlog = 1000' >> /etc/sysctl.conf
sysctl -p

# 调整文件描述符限制
ulimit -n 65536
```

### 故障诊断步骤

1. **检查网络连通性**
   ```bash
   ping <target-host>
   traceroute <target-host>
   ```

2. **监控网络性能**
   ```bash
   # 使用iperf测试带宽
   iperf -s
   iperf -c <server-ip>
   
   # 监控网络接口
   sar -n DEV 1
   ```

3. **分析连接状态**
   ```bash
   # 查看TCP连接状态
   netstat -an | grep ESTABLISHED | wc -l
   ss -s
   
   # 查看TIME_WAIT连接
   netstat -an | grep TIME_WAIT | wc -l
   ```

**章节来源**
- [NetTimeoutException.java](file://client/src/main/java/com/github/dtprj/dongting/net/NetTimeoutException.java#L20-L30)

## Raft集群性能优化

### 问题描述

Raft集群性能不理想，吞吐量和延迟不符合预期。

### 可能原因分析

1. **刷盘策略不当**：同步刷盘影响性能
2. **网络延迟**：节点间通信延迟高
3. **硬件性能瓶颈**：磁盘IO或网络带宽不足
4. **配置不合理**：选举超时、心跳间隔设置不当

### 解决方案

#### 1. 优化刷盘策略

```java
// 同步刷盘配置（高一致性，低性能）
RaftServerConfig syncConfig = new RaftServerConfig();
syncConfig.setSyncWrite(true);

// 异步刷盘配置（高性能，低一致性）
RaftServerConfig asyncConfig = new RaftServerConfig();
asyncConfig.setSyncWrite(false);
```

#### 2. 调整集群配置

```java
// 优化选举和心跳配置
RaftServerConfig config = new RaftServerConfig();
config.setElectionTimeoutMs(1500); // 选举超时1.5秒
config.setHeartbeatIntervalMs(500); // 心跳间隔0.5秒
config.setLogBatchSize(1024); // 日志批处理大小
```

#### 3. 性能监控和调优

```java
// 启用性能监控
PerfCallback perfCallback = new PrometheusPerfCallback();
config.setPerfCallback(perfCallback);

// 监控关键指标
// TPS吞吐量
// 平均响应时间
// 日志复制延迟
// Leader选举时间
```

#### 4. 硬件优化建议

```bash
# 使用高性能SSD
hdparm -tT /dev/sda

# 调整文件系统参数
mount -o remount,noatime,nodiratime /data

# 优化JVM参数
-Xms4G -Xmx4G -XX:+UseZGC -XX:+UnlockExperimentalVMOptions
```

### 性能基准测试

根据项目文档中的测试结果：

| 测试场景 | 单节点TPS | 3节点集群TPS | 平均延迟 |
|---------|----------|-------------|---------|
| 同步刷盘 | 704,900 | 272,540 | 7.3ms |
| 异步刷盘 | 1,777,224 | 903,760 | 2.2ms |

**章节来源**
- [2024_07_09_第二点阶段性进展.md](file://devlogs/2024_07_09_第二点阶段性进展.md#L20-L47)

## Fiber使用最佳实践

### 问题描述

Fiber使用不当导致性能问题或难以维护的代码。

### 最佳实践指南

#### 1. 正确的Fiber创建和管理

```java
// 创建Dispatcher和FiberGroup
Dispatcher dispatcher = new Dispatcher("myDispatcher");
dispatcher.start();

FiberGroup fiberGroup = new FiberGroup("myGroup", dispatcher);
dispatcher.startGroup(fiberGroup).get();

// 启动Fiber
Fiber fiber = new Fiber("myFiber", fiberGroup, new MyFiberFrame());
fiberGroup.fireFiber(fiber);
```

#### 2. 异步操作的最佳实践

```java
public class AsyncOperationExample extends FiberFrame<String> {
    @Override
    public FrameCallResult execute(Void input) {
        // 异步读取文件
        FiberFuture<byte[]> future = getFiberGroup().newFuture("readFile");
        
        Files.readAsync(path, buffer, new CompletionHandler<>() {
            @Override
            public void completed(Integer result, Object attachment) {
                future.fireComplete(buffer.array());
            }
            
            @Override
            public void failed(Throwable exc, Object attachment) {
                future.fireCompleteExceptionally(exc);
            }
        });
        
        return future.await(this::processResult);
    }
    
    private FrameCallResult processResult(byte[] data) {
        // 处理数据
        setResult(new String(data));
        return Fiber.frameReturn();
    }
}
```

#### 3. 错误处理和资源清理

```java
@Override
protected FrameCallResult handle(Throwable ex) {
    // 记录错误日志
    log.error("Fiber execution failed", ex);
    
    // 返回适当的错误码或结果
    return Fiber.frameReturn();
}

@Override
protected FrameCallResult doFinally() {
    // 清理资源
    if (resource != null) {
        resource.close();
    }
    return Fiber.frameReturn();
}
```

#### 4. 避免常见的陷阱

```java
// 错误：在FiberFrame中使用阻塞操作
public FrameCallResult wrongApproach() {
    // 这会导致整个Dispatcher挂起
    Thread.sleep(1000); // ❌ 错误
    return Fiber.frameReturn();
}

// 正确：使用Fiber.sleep
public FrameCallResult correctApproach() {
    return Fiber.sleep(1000, this::afterSleep);
}

private FrameCallResult afterSleep(Void v) {
    return Fiber.frameReturn();
}
```

**章节来源**
- [2024_07_16_3000行代码实现fiber.md](file://devlogs/2024_07_16_3000行代码实现fiber.md#L100-L200)

## 故障排除指南

### 常见故障类型和解决方案

#### 1. 启动失败

**症状**：应用程序启动时抛出异常

**排查步骤**：
```java
// 1. 检查配置文件
try {
    loadConfiguration();
} catch (ConfigurationException e) {
    log.error("Configuration loading failed", e);
    // 检查配置文件格式和内容
}

// 2. 检查端口占用
try {
    bindPort(port);
} catch (BindException e) {
    log.error("Port {} is already in use", port);
    // 更换端口或终止占用进程
}
```

#### 2. 内存溢出

**症状**：OutOfMemoryError异常

**解决方案**：
```java
// 1. 调整JVM堆大小
-Xms2G -Xmx8G

// 2. 启用GC日志
-XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps

// 3. 使用内存分析工具
jmap -dump:format=b,file=heap.hprof <pid>
```

#### 3. 线程池耗尽

**症状**：线程池满，新任务无法提交

**解决方案**：
```java
// 1. 监控线程池状态
ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newCachedThreadPool();
System.out.println("Active threads: " + executor.getActiveCount());
System.out.println("Queue size: " + executor.getQueue().size());

// 2. 调整线程池配置
ThreadPoolExecutor fixedExecutor = new ThreadPoolExecutor(
    corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.SECONDS, 
    new LinkedBlockingQueue<>(queueCapacity));
```

#### 4. 数据不一致

**症状**：集群中数据不一致

**排查步骤**：
```java
// 1. 检查日志复制状态
RaftStatus status = raftNode.getStatus();
System.out.println("Commit index: " + status.getCommitIndex());
System.out.println("Last applied: " + status.getLastApplied());

// 2. 检查节点状态
for (RaftNode node : raftNode.getNodes()) {
    System.out.println("Node " + node.getNodeId() + " status: " + node.getStatus());
}
```

### 调试技巧

#### 1. 启用详细日志

```java
// 设置日志级别
Logger rootLogger = Logger.getRootLogger();
rootLogger.setLevel(Level.DEBUG);

// 特定组件日志
Logger raftLogger = Logger.getLogger("com.github.dtprj.dongting.raft");
raftLogger.setLevel(Level.TRACE);
```

#### 2. 使用性能监控

```java
// 启用性能回调
PerfCallback callback = new SimplePerfCallback();
callback.start();

// 收集性能数据
Map<String, Double> metrics = callback.getMetrics();
System.out.println("TPS: " + metrics.get("tps"));
System.out.println("Latency: " + metrics.get("latency"));
```

#### 3. 网络抓包分析

```bash
# 使用tcpdump抓包
tcpdump -i any -w raft_traffic.pcap port 5001

# 使用Wireshark分析
wireshark raft_traffic.pcap
```

## 总结

本文档涵盖了Dongting项目中常见的技术问题和解决方案，主要包括：

1. **节点选举问题**：通过网络连通性检查、配置验证和时间同步来解决
2. **Fiber死锁**：通过调试信息、资源管理和超时设置来预防和解决
3. **对象池耗尽**：通过监控、配置调整和优雅的资源管理来处理
4. **网络超时**：通过连接配置优化、重连机制和网络调优来改善
5. **性能优化**：通过刷盘策略、集群配置和硬件优化来提升性能
6. **最佳实践**：通过正确的Fiber使用和错误处理来提高代码质量

这些问题的解决不仅需要技术知识，还需要系统性的思维和细致的观察。建议用户在遇到问题时，按照本文档提供的步骤逐步排查，并结合具体的业务场景进行调整。

随着Dongting项目的不断发展，我们将持续更新和完善这份FAQ文档，为用户提供更好的技术支持和服务。