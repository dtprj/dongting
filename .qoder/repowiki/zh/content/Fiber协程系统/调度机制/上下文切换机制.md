# Fiber上下文切换机制

<cite>
**本文档中引用的文件**
- [Dispatcher.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/Dispatcher.java)
- [Fiber.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/Fiber.java)
- [FiberFrame.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/FiberFrame.java)
- [FiberGroup.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/FiberGroup.java)
- [DispatcherThread.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/DispatcherThread.java)
- [YieldTest.java](file://server/src/test/java/com/github/dtprj/dongting/fiber/YieldTest.java)
- [FiberException.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/FiberException.java)
</cite>

## 目录
1. [简介](#简介)
2. [系统架构概览](#系统架构概览)
3. [核心组件分析](#核心组件分析)
4. [上下文切换机制详解](#上下文切换机制详解)
5. [Fiber状态管理](#fiber状态管理)
6. [调度器工作原理](#调度器工作原理)
7. [性能优化与开销分析](#性能优化与开销分析)
8. [故障排除指南](#故障排除指南)
9. [总结](#总结)

## 简介

Dongting Fiber是一个高性能的协程框架，实现了轻量级的用户态线程调度。其核心在于高效的上下文切换机制，通过Fiber、FiberFrame和Dispatcher等组件协同工作，实现了类似于Go语言goroutine的并发模型，但具有更低的内存开销和更高的性能。

Fiber上下文切换机制是整个框架的核心，它负责在不同的Fiber实例之间进行高效的状态保存和恢复，确保协程能够正确地暂停和恢复执行。这种机制使得开发者可以编写出既简单又高效的异步代码。

## 系统架构概览

```mermaid
graph TB
subgraph "Fiber调度层"
Dispatcher[调度器<br/>Dispatcher]
DispatcherThread[调度线程<br/>DispatcherThread]
FiberGroup[协程组<br/>FiberGroup]
end
subgraph "协程执行层"
Fiber[Fiber实例<br/>Fiber]
FiberFrame[Fiber帧<br/>FiberFrame]
StackTop[栈顶帧<br/>stackTop]
end
subgraph "状态管理"
ReadyQueue[就绪队列<br/>readyFibers]
ScheduleQueue[调度队列<br/>scheduleQueue]
CurrentFiber[当前协程<br/>currentFiber]
end
Dispatcher --> DispatcherThread
DispatcherThread --> FiberGroup
FiberGroup --> Fiber
Fiber --> FiberFrame
FiberFrame --> StackTop
Dispatcher --> ReadyQueue
Dispatcher --> ScheduleQueue
FiberGroup --> CurrentFiber
Fiber -.-> FiberFrame
FiberFrame -.-> Fiber
```

**图表来源**
- [Dispatcher.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/Dispatcher.java#L40-L120)
- [FiberGroup.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/FiberGroup.java#L32-L98)

## 核心组件分析

### Dispatcher调度器

Dispatcher是整个Fiber系统的中央调度器，负责管理所有Fiber的执行和上下文切换。

```mermaid
classDiagram
class Dispatcher {
+Timestamp ts
+PoolFactory poolFactory
+PerfCallback perfCallback
+FiberQueue shareQueue
+ArrayList~FiberGroup~ groups
+IndexedQueue~FiberGroup~ readyGroups
+PriorityQueue~Fiber~ scheduleQueue
+DispatcherThread thread
+boolean poll
+long pollTimeout
+volatile boolean shouldStop
+int round
+startGroup(FiberGroup) CompletableFuture~Void~
+doStart() void
+doStop(DtTime, boolean) void
-run() void
-runImpl(ArrayList~FiberQueueTask~) void
-processScheduleFibers() void
-execGroup(FiberGroup) void
-execFiber(FiberGroup, Fiber) void
-execFrame(Fiber, FiberFrame) void
+call(FiberFrame, FrameCall) void
+resume(Object, Throwable, FrameCall) void
+awaitOn(WaitSource, long, FrameCall) FrameCallResult
+sleep(long, FrameCall) FrameCallResult
+yield(FrameCall) void
}
class DispatcherThread {
+FiberGroup currentGroup
+ByteBufferPool directPool
+RefBufferFactory heapPool
+currentDispatcherThread() DispatcherThread
+currentGroup() FiberGroup
}
class FiberGroup {
+String name
+Dispatcher dispatcher
+CompletableFuture~Void~ shutdownFuture
+FiberCondition shouldStopCondition
+IndexedQueue~Fiber~ readyFibers
+IndexedQueue~Fiber~ readyFibersNextRound1
+IndexedQueue~Fiber~ readyFibersNextRound2
+IdentityHashMap~Fiber,Fiber~ normalFibers
+IdentityHashMap~Fiber,Fiber~ daemonFibers
+volatile boolean shouldStop
+boolean finished
+boolean ready
+Fiber currentFiber
+GroupExecutor executor
+fireFiber(Fiber) boolean
+fireFiber(String, FiberFrame) boolean
+requestShutdown() void
+start(Fiber, boolean) void
+tryMakeFiberReady(Fiber, boolean) void
+updateFinishStatus() void
}
Dispatcher --> DispatcherThread : "管理"
Dispatcher --> FiberGroup : "调度"
FiberGroup --> Fiber : "包含"
DispatcherThread --> FiberGroup : "关联"
```

**图表来源**
- [Dispatcher.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/Dispatcher.java#L40-L120)
- [FiberGroup.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/FiberGroup.java#L32-L98)
- [DispatcherThread.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/DispatcherThread.java#L25-L48)

### Fiber实例

Fiber是协程的基本执行单元，每个Fiber都有自己的调用栈和执行状态。

```mermaid
classDiagram
class Fiber {
+String name
+FiberGroup group
+boolean daemon
+long scheduleTimeout
+long scheduleNanoTime
+boolean started
+boolean ready
+boolean finished
+boolean interrupted
+WaitSource source
+FiberCondition[] sourceConditions
+FiberFrame stackTop
+Object inputObj
+Throwable inputEx
+short signalCountInEachRound
+int roundInfo
+Fiber(String, FiberGroup, FiberFrame)
+Fiber(String, FiberGroup, FiberFrame, boolean)
+Fiber(String, FiberGroup, FiberFrame, boolean, int)
+call(FiberFrame, FrameCall) FrameCallResult
+resume(Object, FrameCall) FrameCallResult
+sleep(long, FrameCall) FrameCallResult
+yield(FrameCall) FrameCallResult
+join(FrameCall) FrameCallResult
+interrupt() void
+start() void
+popFrame() void
+pushFrame(FiberFrame) void
+cleanSchedule() void
}
class FiberFrame {
+Fiber fiber
+FiberFrame prev
+boolean catchCalled
+boolean finallyCalled
+FrameCall resumePoint
+O frameResult
+Throwable frameEx
+init(Fiber) void
+reset() void
+doFinally() FrameCallResult
+handle(Throwable) FrameCallResult
+execute(Object) FrameCallResult
}
class WaitSource {
+String name
+FiberGroup group
+LinkedList~Fiber~ waiters
+prepare(Fiber, boolean) void
+signalLater() void
+signalAll() void
}
Fiber --> FiberFrame : "维护栈顶"
FiberFrame --> Fiber : "属于"
FiberFrame --|> WaitSource : "继承"
```

**图表来源**
- [Fiber.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/Fiber.java#L30-L83)
- [FiberFrame.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/FiberFrame.java#L20-L60)

**章节来源**
- [Dispatcher.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/Dispatcher.java#L40-L120)
- [Fiber.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/Fiber.java#L30-L83)
- [FiberFrame.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/FiberFrame.java#L20-L60)
- [FiberGroup.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/FiberGroup.java#L32-L98)

## 上下文切换机制详解

### execFiber方法：核心上下文切换引擎

`execFiber`方法是Fiber上下文切换的核心，它负责执行一个Fiber的所有帧直到该Fiber被暂停或完成。

```mermaid
flowchart TD
Start([开始执行Fiber]) --> SaveCurrent["保存currentFiber到FiberGroup"]
SaveCurrent --> GetStackTop["获取Fiber的栈顶帧"]
GetStackTop --> LoopStart{"栈顶帧不为空?"}
LoopStart --> |是| ExecFrame["调用execFrame执行当前帧"]
ExecFrame --> CheckFatal{"存在致命错误?"}
CheckFatal --> |是| HandleFatal["处理致命错误"]
CheckFatal --> |否| CheckReady{"Fiber是否就绪?"}
CheckReady --> |否| CheckYield{"是否为yield操作?"}
CheckYield --> |是| CleanSchedule["清理调度信息"]
CleanSchedule --> SetReady["设置ready=true"]
SetReady --> AddNextRound["添加到readyFibersNextRound2"]
AddNextRound --> Return["返回控制权"]
CheckReady --> |是| CheckSameFrame{"当前帧是否等于栈顶帧?"}
CheckSameFrame --> |是| HasResumePoint{"是否有恢复点?"}
HasResumePoint --> |是| Continue["继续执行"]
HasResumePoint --> |否| PopFrame["弹出当前帧"]
PopFrame --> GetNewStackTop["获取新的栈顶帧"]
CheckSameFrame --> |否| NewFrame["新调用的帧"]
NewFrame --> GetNewStackTop
CheckReady --> |否且非yield| Return
GetNewStackTop --> LoopStart
LoopStart --> |否| Complete["Fiber执行完成"]
Complete --> SetFinished["设置finished=true"]
SetFinished --> RemoveFiber["从FiberGroup移除"]
RemoveFiber --> SignalAll["唤醒等待的Fiber"]
SignalAll --> RestoreCurrent["恢复currentFiber为null"]
RestoreCurrent --> End([结束])
HandleFatal --> LogError["记录错误日志"]
LogError --> RestoreCurrent
Return --> End
```

**图表来源**
- [Dispatcher.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/Dispatcher.java#L279-L327)

### execFrame方法：单帧执行引擎

`execFrame`方法负责执行单个FiberFrame的逻辑，并处理可能的异常情况。

```mermaid
sequenceDiagram
participant DF as Dispatcher
participant FF as FiberFrame
participant F as Fiber
participant RP as ResumePoint
DF->>FF : execFrame(fiber, currentFrame)
FF->>FF : 检查inputEx异常
alt 存在异常
FF->>FF : 处理异常
FF->>FF : 调用tryHandleEx
FF->>FF : 设置frameEx
else 正常执行
FF->>FF : 获取input对象
FF->>FF : 清空inputObj
FF->>RP : 执行resumePoint.execute(input)
alt resumePoint抛出异常
FF->>FF : 处理异常
FF->>FF : 设置fiber.inputEx
end
end
FF->>FF : 执行finally块
FF->>FF : 检查finallyCalled标志
alt finally未执行且没有恢复点
FF->>FF : 调用doFinally()
FF->>FF : 设置catchCalled=true
FF->>FF : 设置finallyCalled=true
end
FF-->>DF : 返回执行结果
```

**图表来源**
- [Dispatcher.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/Dispatcher.java#L327-L367)

### FiberFrame栈结构管理

Fiber使用链表结构维护调用栈，每个FiberFrame代表一次函数调用。

```mermaid
graph LR
subgraph "Fiber栈结构"
StackTop[栈顶帧<br/>stackTop]
Frame1[Frame1<br/>当前执行帧]
Frame2[Frame2]
Frame3[Frame3]
Bottom[底部帧<br/>入口帧]
end
StackTop --> Frame1
Frame1 --> Frame2
Frame2 --> Frame3
Frame3 --> Bottom
subgraph "帧属性"
Prev[prev指针]
ResumePoint[resumePoint]
Result[frameResult]
Exception[frameEx]
CatchFlag[catchCalled]
FinallyFlag[finallyCalled]
end
Frame1 -.-> Prev
Frame1 -.-> ResumePoint
Frame1 -.-> Result
Frame1 -.-> Exception
Frame1 -.-> CatchFlag
Frame1 -.-> FinallyFlag
```

**图表来源**
- [Fiber.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/Fiber.java#L55-L83)
- [FiberFrame.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/FiberFrame.java#L20-L60)

**章节来源**
- [Dispatcher.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/Dispatcher.java#L279-L367)
- [Fiber.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/Fiber.java#L120-L150)

## Fiber状态管理

### 状态转换图

```mermaid
stateDiagram-v2
[*] --> Created : 创建Fiber
Created --> Started : 调用start()
Started --> Running : 调度器执行
Running --> Ready : yield/SUSPEND
Running --> Suspended : awaitOn/sleep
Running --> Finished : 执行完成
Running --> Interrupted : 被中断
Ready --> Running : 调度器选择
Ready --> Suspended : awaitOn/sleep
Ready --> Finished : 执行完成
Suspended --> Running : 唤醒/超时
Suspended --> Interrupted : 被中断
Suspended --> Finished : 执行完成
Interrupted --> Finished : 清理资源
Finished --> [*] : 销毁
note right of Running : 可以被暂停或恢复
note right of Suspended : 等待事件或超时
note right of Ready : 等待调度器
```

### 暂停（SUSPEND）与恢复机制

Fiber的暂停和恢复通过resumePoint机制实现：

```mermaid
sequenceDiagram
participant CF as 当前Fiber
participant DS as 调度器
participant WS as 等待源
participant NF as 新Fiber
Note over CF,NF : Fiber暂停流程
CF->>CF : 设置ready=false
CF->>DS : 添加到调度队列
CF->>WS : 注册等待源
CF->>CF : 设置resumePoint
CF->>DS : 返回SUSPEND
DS->>DS : 保存currentFiber
DS->>NF : 继续执行下一个Fiber
Note over CF,NF : Fiber恢复流程
WS->>DS : 触发事件/超时
DS->>DS : 从调度队列取出Fiber
DS->>CF : 设置inputObj/inputEx
DS->>CF : 设置ready=true
DS->>CF : 设置resumePoint=null
DS->>DS : 恢复currentFiber
DS->>CF : 继续执行resumePoint
```

**图表来源**
- [Dispatcher.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/Dispatcher.java#L429-L439)

### Dispatcher的ready标志位管理

Dispatcher通过多个队列管理Fiber的就绪状态：

```mermaid
graph TB
subgraph "Fiber就绪队列层次"
ReadyFibers[readyFibers<br/>当前轮次优先执行]
NextRound1[readyFibersNextRound1<br/>下一轮次头部插入]
NextRound2[readyFibersNextRound2<br/>下一轮次尾部插入]
end
subgraph "调度策略"
RoundRobin[轮询调度]
Priority[优先级处理]
SignalCount[信号计数控制]
end
ReadyFibers --> RoundRobin
NextRound1 --> Priority
NextRound2 --> Priority
subgraph "状态转换"
Yield[Yield操作]
Call[函数调用]
Suspend[暂停操作]
end
Yield --> NextRound2
Call --> ReadyFibers
Suspend --> NextRound1
```

**图表来源**
- [FiberGroup.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/FiberGroup.java#L40-L50)

**章节来源**
- [Dispatcher.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/Dispatcher.java#L429-L439)
- [FiberGroup.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/FiberGroup.java#L200-L250)

## 调度器工作原理

### 调度循环机制

```mermaid
flowchart TD
Start([调度器启动]) --> RefreshTime["刷新时间戳"]
RefreshTime --> CheckStop{"检查停止标志"}
CheckStop --> |已停止且无组| Shutdown["关闭调度器"]
CheckStop --> |继续运行| RunImpl["执行调度循环"]
RunImpl --> FillTasks["填充任务队列"]
FillTasks --> ProcessSchedule["处理调度中的Fiber"]
ProcessSchedule --> ExecuteReady["执行就绪Fiber"]
ExecuteReady --> UpdateGroups["更新组状态"]
UpdateGroups --> CleanPool["清理内存池"]
CleanPool --> RefreshPerf["刷新性能统计"]
RefreshPerf --> IncrementRound["递增轮次计数"]
IncrementRound --> CheckStop
subgraph "执行就绪Fiber"
SelectGroup["选择FiberGroup"]
SelectGroup --> ExecGroup["执行组内Fiber"]
ExecGroup --> CheckGroupReady{"组是否就绪?"}
CheckGroupReady --> |是| AddBack["重新加入readyGroups"]
CheckGroupReady --> |否| NextGroup["下一个组"]
AddBack --> SelectGroup
NextGroup --> SelectGroup
end
ExecuteReady --> SelectGroup
UpdateGroups --> CheckStop
Shutdown --> End([结束])
```

**图表来源**
- [Dispatcher.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/Dispatcher.java#L120-L180)

### 性能监控与优化

调度器集成了详细的性能监控机制：

```mermaid
graph LR
subgraph "性能指标"
WorkTime[工作时间<br/>FIBER_D_WORK]
PollTime[轮询时间<br/>FIBER_D_POLL]
QueueSize[队列大小]
FiberCount[协程数量]
end
subgraph "监控回调"
PerfCallback[PerfCallback接口]
PerfConsts[性能常量]
PerfStats[性能统计]
end
subgraph "优化策略"
AdaptivePoll[自适应轮询]
BatchProcess[批量处理]
MemoryClean[内存清理]
end
WorkTime --> PerfCallback
PollTime --> PerfCallback
QueueSize --> PerfCallback
FiberCount --> PerfCallback
PerfCallback --> PerfConsts
PerfCallback --> PerfStats
PerfStats --> AdaptivePoll
PerfStats --> BatchProcess
PerfStats --> MemoryClean
```

**图表来源**
- [Dispatcher.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/Dispatcher.java#L180-L220)

**章节来源**
- [Dispatcher.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/Dispatcher.java#L120-L220)

## 性能优化与开销分析

### 上下文切换性能开销

Fiber上下文切换相比传统线程切换具有显著优势：

| 操作类型 | 开销级别 | 说明 |
|---------|---------|------|
| Fiber切换 | 微秒级 | 仅需保存/恢复寄存器和栈指针 |
| 线程切换 | 毫秒级 | 需要保存整个CPU上下文 |
| 内存分配 | 取决于池化 | 使用对象池减少分配开销 |
| 锁竞争 | 减少 | 协程间通信避免锁 |

### 优化技术

1. **对象池化**: 使用ByteBufferPool和RefBufferFactory减少GC压力
2. **批量处理**: 通过IndexedQueue和PriorityQueue提高批量操作效率
3. **自适应轮询**: 根据负载动态调整轮询超时时间
4. **内存预分配**: 提前分配常用对象减少运行时分配

### 性能基准测试

```mermaid
graph TB
subgraph "性能测试场景"
CreateFiber[创建Fiber测试]
ChannelCross[跨线程通道测试]
FiberChannel[Fiber通道测试]
FiberTest[Fiber基础测试]
end
subgraph "性能指标"
Throughput[吞吐量]
Latency[延迟]
MemoryUsage[内存使用]
CPUUsage[CPU使用率]
end
CreateFiber --> Throughput
ChannelCross --> Latency
FiberChannel --> MemoryUsage
FiberTest --> CPUUsage
```

**章节来源**
- [Dispatcher.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/Dispatcher.java#L80-L120)

## 故障排除指南

### 常见问题诊断

1. **Fiber死锁**
   - 检查waiters队列是否为空
   - 验证resumePoint是否正确设置
   - 确认信号量发送是否正常

2. **内存泄漏**
   - 监控FiberGroup中的normalFibers和daemonFibers集合
   - 检查Fiber是否正确标记为finished
   - 验证finally块是否被执行

3. **性能问题**
   - 分析调度器轮询时间占比
   - 检查内存池使用情况
   - 监控Fiber栈深度

### 调试工具

```mermaid
graph LR
subgraph "调试工具"
FiberInfo[Fiber信息查询]
GroupInfo[组状态查看]
StackTrace[虚拟栈跟踪]
PerfMonitor[性能监控]
end
subgraph "输出格式"
TextOutput[文本输出]
JsonOutput[JSON输出]
GraphOutput[图形输出]
end
FiberInfo --> TextOutput
GroupInfo --> JsonOutput
StackTrace --> GraphOutput
PerfMonitor --> TextOutput
```

**图表来源**
- [FiberException.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/FiberException.java#L35-L83)

**章节来源**
- [FiberException.java](file://server/src/main/java/com/github/dtprj/dongting/fiber/FiberException.java#L35-L83)

## 总结

Dongting Fiber的上下文切换机制通过精心设计的组件协作，实现了高效、可靠的协程调度。关键特性包括：

1. **高效的上下文切换**: 通过execFiber和execFrame方法实现最小化的状态保存和恢复
2. **灵活的调度策略**: 支持多种调度队列和优先级处理
3. **完善的异常处理**: 提供完整的异常传播和处理机制
4. **优秀的性能表现**: 相比传统线程切换具有显著的性能优势
5. **丰富的调试支持**: 提供详细的日志和性能监控功能

这种设计使得开发者能够编写出既简单又高效的异步代码，同时保持良好的可维护性和可调试性。Fiber上下文切换机制是整个框架性能和可靠性的基石，为构建高性能的分布式系统提供了强有力的支持。