# 安装与配置

<cite>
**本文档中引用的文件**   
- [RaftServerConfig.java](file://server/src/main/java/com/github/dtprj/dongting/raft/server/RaftServerConfig.java)
- [NioConfig.java](file://client/src/main/java/com/github/dtprj/dongting/net/NioConfig.java)
- [StandaloneDemoServer.java](file://demos/src/main/java/com/github/dtprj/dongting/demos/standalone/StandaloneDemoServer.java)
- [DemoKvServerBase.java](file://demos/src/main/java/com/github/dtprj/dongting/demos/base/DemoKvServerBase.java)
- [pom.xml](file://pom.xml)
</cite>

## 目录
1. [通过Maven引入依赖](#通过maven引入依赖)
2. [服务器配置（RaftServerConfig）](#服务器配置raftserverconfig)
3. [客户端配置（NioConfig）](#客户端配置nioconfig)
4. [完整配置示例](#完整配置示例)
5. [生产环境最佳实践](#生产环境最佳实践)

## 通过Maven引入依赖

Dongting 项目采用 Maven 进行构建管理，其核心特点是零外部依赖（除了可选的 SLF4J 日志框架）。要将 Dongting 作为依赖引入您的 Java 项目，您需要在 `pom.xml` 文件中添加以下依赖项。

Dongting 分为两个独立的 JAR 包：`client` 和 `server`。根据您的使用场景，可以选择引入其中一个或两个都引入。

```xml
<dependencies>
    <!-- 引入 Dongting 客户端 -->
    <dependency>
        <groupId>com.github.dtprj.dongting</groupId>
        <artifactId>client</artifactId>
        <version>0.8.3-SNAPSHOT</version>
    </dependency>

    <!-- 引入 Dongting 服务端 -->
    <dependency>
        <groupId>com.github.dtprj.dongting</groupId>
        <artifactId>server</artifactId>
        <version>0.8.3-SNAPSHOT</version>
    </dependency>

    <!-- 可选：SLF4J 日志门面，如果未引入，Dongting 将使用 JDK 内置日志 -->
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-api</artifactId>
        <version>2.0.17</version>
        <optional>true</optional>
    </dependency>
</dependencies>
```

**重要说明**：
- **Java 版本要求**：客户端需要 Java 8 或更高版本，服务端需要 Java 11 或更高版本。
- **轻量级**：Dongting 的两个 JAR 包总大小不足 1MB，且没有传递性依赖，可以轻松嵌入到任何应用中。
- **可选日志**：SLF4J 是可选的。如果您的类路径中没有 SLF4J，Dongting 将自动回退到使用 `java.util.logging`。

**Section sources**
- [pom.xml](file://pom.xml)

## 服务器配置（RaftServerConfig）

`RaftServerConfig` 类用于配置 Dongting Raft 服务器节点的核心参数。这些配置决定了节点的网络行为、选举机制和集群成员关系。

### 核心配置项

| 配置项 | 作用 | 默认值 | 取值范围 | 调优建议 |
| :--- | :--- | :--- | :--- | :--- |
| `servers` | 定义集群中所有节点的地址列表，格式为 `nodeId,host:replicatePort`，多个节点用分号分隔。 | `null` | 字符串，必须包含所有节点信息 | 确保所有节点的配置中 `servers` 列表完全一致，否则可能导致集群无法形成。 |
| `nodeId` | 当前节点的唯一标识符，必须在 `servers` 列表中定义。 | `null` | 正整数 | 选择一个在集群中唯一的、易于识别的 ID。 |
| `replicatePort` | 用于节点间 Raft 日志复制和管理命令通信的端口。 | `null` | 正整数 | 确保该端口在服务器防火墙中是开放的，并且不与其他服务冲突。 |
| `servicePort` | 用于客户端访问（读写请求）的端口。设为 0 表示不启动客户端服务。 | `0` | 非负整数 | 在生产环境中，通常会将复制端口和服务端口分开，以实现网络隔离。 |
| `electTimeout` | 选举超时时间。当一个 Follower 在此时间内未收到 Leader 的心跳，将发起新的选举。 | `15000` (15秒) | 正整数（毫秒） | **调优关键**：该值应远大于 `heartbeatInterval`（通常为 5-10 倍）。值过小会导致不必要的选举，增加网络开销；值过大则故障恢复时间变长。在低延迟网络中可适当调小。 |
| `heartbeatInterval` | Leader 向 Follower 发送心跳的间隔时间。 | `2000` (2秒) | 正整数（毫秒） | **调优关键**：这是维持集群稳定的关键参数。值越小，集群对故障的反应越快，但网络开销越大。建议根据网络延迟进行调整，通常设置为 1-2 秒。 |
| `rpcTimeout` | 节点间 RPC 调用的超时时间。 | `5000` (5秒) | 正整数（毫秒） | 应大于网络往返时间（RTT）和节点处理时间。如果网络不稳定，可适当增加。 |
| `connectTimeout` | 建立 TCP 连接的超时时间。 | `2000` (2秒) | 正整数（毫秒） | 一般无需调整，除非在高延迟网络中。 |
| `blockIoThreads` | 处理 I/O 事件的线程数。 | `Math.max(Runtime.getRuntime().availableProcessors() * 2, 4)` | 正整数 | 默认值通常足够。在高吞吐场景下，可设置为 CPU 核心数的 2-4 倍以充分利用多核性能。 |

**Section sources**
- [RaftServerConfig.java](file://server/src/main/java/com/github/dtprj/dongting/raft/server/RaftServerConfig.java)

## 客户端配置（NioConfig）

`NioConfig` 是一个抽象类，被 `NioClientConfig` 和 `NioServerConfig` 继承，用于配置网络 I/O 的行为。它定义了客户端与服务器通信时的底层网络参数。

### 核心配置项

| 配置项 | 作用 | 默认值 | 取值范围 | 调优建议 |
| :--- | :--- | :--- | :--- | :--- |
| `bizThreads` | 业务处理线程数。设为 0 表示使用 I/O 线程直接处理业务逻辑。 | `0` | 非负整数 | 对于计算密集型任务，建议设置一个独立的业务线程池（>0），以避免阻塞 I/O 线程。对于轻量级操作，设为 0 可以减少线程切换开销。 |
| `name` | 配置实例的名称，主要用于日志和监控。 | `null` | 字符串 | 建议设置一个有意义的名称，便于在日志中区分不同的客户端或服务器实例。 |
| `maxOutRequests` / `maxOutBytes` | 客户端到服务器方向的背压控制。限制待发送的请求数量和字节数。 | `0` | 非负整数 | 设为 0 表示不启用此限制。在高并发场景下，可以设置合理的值来防止内存溢出。 |
| `maxInRequests` / `maxInBytes` | 服务器到客户端方向的背压控制。限制待处理的响应数量和字节数。 | `0` | 非负整数 | 同上，用于保护服务器端。 |
| `selectTimeout` | I/O 线程在 `Selector.select()` 上的阻塞超时时间。 | `50` (50毫秒) | 正整数（毫秒） | 影响 I/O 线程的响应速度。值越小，线程越“活跃”，但 CPU 占用率越高。默认值 50ms 是一个良好的平衡点。 |
| `cleanInterval` | 清理过期连接和资源的周期。 | `100` (100毫秒) | 正整数（毫秒） | 一般无需调整。 |
| `nearTimeoutThreshold` | 接近超时的阈值，用于提前触发超时检查。 | `850` (850毫秒) | 正整数（毫秒） | 与 `rpcTimeout` 配合使用，确保超时能被及时检测。 |
| `maxPacketSize` | 单个网络包的最大大小。 | `5 * 1024 * 1024` (5MB) | 正整数 | 应根据您的业务数据大小进行调整。过小会限制单次传输的数据量，过大会增加内存压力和网络延迟。 |
| `maxBodySize` | 消息体的最大大小。 | `4 * 1024 * 1024` (4MB) | 正整数 | 通常应小于 `maxPacketSize`。 |
| `poolFactory` | 缓冲区池工厂，用于管理 `ByteBuffer` 的复用，减少 GC 压力。 | `new DefaultPoolFactory()` | `PoolFactory` 实现 | Dongting 内置了高效的对象池，不建议修改。 |
| `readBufferSize` | 每个连接的读取缓冲区大小。 | `128 * 1024` (128KB) | 正整数 | 根据网络吞吐量调整。在高吞吐场景下，增大此值可以减少 `read()` 系统调用的次数。 |
| `perfCallback` | 性能回调接口，用于收集性能指标。 | `NoopPerfCallback.INSTANCE` | `PerfCallback` 实现 | 在生产环境中，建议实现此接口以监控延迟、吞吐量等关键指标。 |

**Section sources**
- [NioConfig.java](file://client/src/main/java/com/github/dtprj/dongting/net/NioConfig.java)

## 完整配置示例

以下是一个完整的服务器配置示例，展示了如何在代码中初始化一个 Dongting Raft 节点。

```java
// 1. 配置服务器节点
RaftServerConfig serverConfig = new RaftServerConfig();
serverConfig.servers = "1,192.168.1.10:4001;2,192.168.1.11:4001;3,192.168.1.12:4001";
serverConfig.nodeId = 1;
serverConfig.replicatePort = 4001;
serverConfig.servicePort = 5001;
// 为快速演示设置较短的超时
serverConfig.electTimeout = 3000; // 3秒
serverConfig.heartbeatInterval = 1000; // 1秒

// 2. 配置 Raft 组
List<RaftGroupConfig> groupConfigs = new ArrayList<>();
RaftGroupConfig groupConfig = new RaftGroupConfig();
groupConfig.groupId = 101;
groupConfig.nodeIdOfMembers = "1,2,3"; // 成员节点
groupConfig.dataDir = "/data/dongting/raft_group_101"; // 数据存储目录

groupConfigs.add(groupConfig);

// 3. 创建 Raft 工厂并指定状态机
DefaultRaftFactory raftFactory = new DefaultRaftFactory() {
    @Override
    public StateMachine createStateMachine(RaftGroupConfigEx groupConfig) {
        // 使用内置的 DtKV 作为状态机
        return new DtKV(groupConfig, new KvConfig());
    }
};

// 4. 启动 Raft 服务器
RaftServer raftServer = new RaftServer(serverConfig, groupConfigs, raftFactory);
// 注册 KV 服务处理器
KvServerUtil.initKvServer(raftServer);
raftServer.start();
```

**Section sources**
- [DemoKvServerBase.java](file://demos/src/main/java/com/github/dtprj/dongting/demos/base/DemoKvServerBase.java)
- [StandaloneDemoServer.java](file://demos/src/main/java/com/github/dtprj/dongting/demos/standalone/StandaloneDemoServer.java)

## 生产环境最佳实践

为了确保 Dongting 集群在生产环境中的高性能和高可用性，请遵循以下最佳实践：

1.  **网络隔离**：将 `replicatePort`（节点间通信）和 `servicePort`（客户端访问）分开。可以将复制流量放在内网或专用网络中，以减少干扰并提高安全性。

2.  **合理设置选举超时**：`electTimeout` 和 `heartbeatInterval` 是一对关键参数。推荐设置 `heartbeatInterval` 为 1-2 秒，`electTimeout` 为其 5-10 倍（即 5-20 秒）。这可以在故障快速检测和避免误选举之间取得平衡。

3.  **数据持久化策略**：`RaftGroupConfig` 中的 `syncForce` 参数控制是否在每次写入后调用 `fsync`。在追求极致性能的场景下，可将其设为 `false`（异步刷盘），但会增加在系统崩溃时丢失少量数据的风险。在金融等对数据一致性要求极高的场景，应保持 `true`（同步刷盘）。

4.  **资源监控**：通过实现 `PerfCallback` 接口，监控关键性能指标，如请求延迟、吞吐量、I/O 线程状态等，以便及时发现性能瓶颈。

5.  **对象池利用**：Dongting 内置了高效的缓冲区对象池。确保在业务代码中正确使用 `RefBuffer` 并及时释放，以避免内存泄漏和不必要的 GC。

6.  **日志配置**：虽然 SLF4J 是可选的，但在生产环境中强烈建议引入 SLF4J 并配置一个成熟的日志框架（如 Logback），以便更好地管理和分析日志。

7.  **硬件选择**：尽管 Dongting 可以在普通硬件上运行，但为了获得最佳性能，建议使用 SSD 存储和高速网络。